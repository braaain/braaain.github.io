<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-08-11T08:48:41.015Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SQL注入</title>
    <link href="http://example.com/2023/08/11/c/"/>
    <id>http://example.com/2023/08/11/c/</id>
    <published>2023-08-11T02:44:06.000Z</published>
    <updated>2023-08-11T08:48:41.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-SQL"><a href="#1-SQL" class="headerlink" title="1.SQL"></a>1.SQL</h4><p>SQL一般是指结构化查询语言,是一种特殊目的的编程语言,是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p><h4 id="2-SQL注入原理"><a href="#2-SQL注入原理" class="headerlink" title="2.SQL注入原理"></a>2.SQL注入原理</h4><p>SQL注入就是当开发人员对用户输入数据的合法性没有判断或过滤不严时,攻击者通过拼接恶意SQL语句诱使解释器在未经适当授权的情况下执行意外命令或访问数据。</p><p>简而言之:SQL注入的原理就是攻击者通过拼接恶意SQL语句，将其带入数据库进行查询，从而得到数据库一些敏感信息。<br><strong>SQL注入，就是通过把SQL命令插入到WEB表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</strong></p><h4 id="3-注入条件"><a href="#3-注入条件" class="headerlink" title="3.注入条件"></a>3.注入条件</h4><p>SQL注入产生条件有三:<br>(1) 变量可控；<br>(2)变量未存在过滤；<br>(3) 我们构造的SQL语句可带入数据库中查询。</p><p><strong>当我们了解SQL注入产生的条件时，还有一个非常重要的点需要特别注意,就是应该了解那个参数存在注入点。</strong></p><h3 id="二、SQL注入类型"><a href="#二、SQL注入类型" class="headerlink" title="二、SQL注入类型"></a>二、SQL注入类型</h3><h4 id="1、按照注入点分类："><a href="#1、按照注入点分类：" class="headerlink" title="1、按照注入点分类："></a>1、按照注入点分类：</h4><p>（1）数字型注入：许多网页链接有类似的结构 <a class="link"   href="http://xxx.com/users.php?id=1" >http://xxx.com/users.php?id=1<i class="fas fa-external-link-alt"></i></a> 基于此种形式的注入，注入点id为数字，一般被叫做数字型注入点，通过这种形式查询出后台数据库信息返回前台展示，可以构造类似以下的SQL语句进行爆破：</p><blockquote><p>select xxx from 表名 where id&#x3D;1 and 1&#x3D;1。</p></blockquote><p>（2）字符型注入：网页链接有类似的结构<a class="link"   href="http://xxx.com/users.php?name=admin" >http://xxx.com/users.php?name=admin<i class="fas fa-external-link-alt"></i></a> 这种形式，注入点name为字符串，被称为字符型注入，可以用：</p><blockquote><p>select xxx from 表名 where name&#x3D;’admin’ and 1&#x3D;1。</p></blockquote><p>（3）搜索型注入：主要是指在数据搜索时没有过滤搜索参数，一般在链接地址中有 “keyword&#x3D;“关键字””，注入点提交的是SQL语句。</p><blockquote><p>select * from 表名 where 字段 like ‘%关键字%’ and ‘%1%’&#x3D;’%1%’。</p></blockquote><h4 id="2、按照执行效果来分类："><a href="#2、按照执行效果来分类：" class="headerlink" title="2、按照执行效果来分类："></a>2、按照执行效果来分类：</h4><p>（1）基于布尔的盲注：根据页面返回判断条件真假注入。</p><p>（2）基于时间的盲注：即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</p><p>（3）基于报错的注入：即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。</p><blockquote><ul><li>单引号</li><li>双引号</li><li>基于数字型注入</li></ul></blockquote><p>（4）联合查询注入：可以使用union情况下注入。</p><h3 id="三、SQL注入常见的绕过方法"><a href="#三、SQL注入常见的绕过方法" class="headerlink" title="三、SQL注入常见的绕过方法"></a>三、SQL注入常见的绕过方法</h3><p>（1）大小写关键词绕过(Union)</p><p>（2）双写关键词绕过(ununionion)</p><p>（3）编码绕过（base64、url）</p><p>（4）内联注释绕过（&#x2F;*! Union *&#x2F;）</p><h3 id="四、SQL注入-般步骤"><a href="#四、SQL注入-般步骤" class="headerlink" title="四、SQL注入-般步骤"></a>四、SQL注入-般步骤</h3><p>1.注入点判断</p><p>2.注入点类型判断(有无回显)</p><blockquote><ul><li>回显的类型判断:</li></ul></blockquote><p>(1)数字型注入</p><blockquote><p>?id&#x3D;1 and 1&#x3D;1 – -<br>?id&#x3D;1 and 1&#x3D;2 – -(是否报错，报错则是)</p></blockquote><p>(2)字符型注入</p><blockquote><p>?id&#x3D;1’ and 1&#x3D;1 – -<br>?id&#x3D;1’ and 1&#x3D;2 – -(是否报错，报错即是)</p></blockquote><blockquote><ul><li>猜字段数:</li></ul></blockquote><p>order by(二分法)</p><blockquote><p>?id&#x3D;2’ order by 6– -</p></blockquote><blockquote><ul><li>找回显：</li></ul></blockquote><blockquote><p>?id&#x3D;2’ union select 1,2,3– -</p></blockquote><p><strong>相关函数：</strong></p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811162026460.png" alt="image-20230811162026460"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">找数据库 database()</span><br><span class="line">在一行显示 group_concat()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>常用系统函数：</strong></p><blockquote><table><thead><tr><th align="center">基础信息函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">system_user()</td><td align="center">系统用户名</td></tr><tr><td align="center">user()</td><td align="center">用户名</td></tr><tr><td align="center">current_user()</td><td align="center">当前用户名</td></tr><tr><td align="center">session_user()</td><td align="center">连接数据库的用户名</td></tr><tr><td align="center">database()</td><td align="center">数据库名</td></tr><tr><td align="center">version()</td><td align="center">数据库版本</td></tr><tr><td align="center">@@datadir</td><td align="center">数据库路径</td></tr><tr><td align="center">@@basedir</td><td align="center">数据库安装路径</td></tr><tr><td align="center">@@version_compile_os</td><td align="center">操作系统</td></tr><tr><td align="center">count()</td><td align="center">返回执行结果数量</td></tr><tr><td align="center">sleep()</td><td align="center">延时</td></tr></tbody></table></blockquote><blockquote><table><thead><tr><th align="left">字符处理函数</th><th align="center">功能</th><th align="center">举例</th></tr></thead><tbody><tr><td align="left">重点 concat()</td><td align="center">没有分隔符地连接字符串</td><td align="center">select concat(c1,c2) from xxx</td></tr><tr><td align="left">重点 concat_ws()</td><td align="center">指定分隔符地连接字符串</td><td align="center">select concat_ws(‘:’,c1,c2) from xxx</td></tr><tr><td align="left">重点 group_concat()</td><td align="center">以逗号分隔某列&#x2F;组的数据</td><td align="center">select group_concat(c1,c2) from xxx</td></tr><tr><td align="left">load_file()</td><td align="center">读取服务器文件</td><td align="center">select loadfile(‘&#x2F;tmp&#x2F;a.txt’)</td></tr><tr><td align="left">into outfile</td><td align="center">写入文件到服务器</td><td align="center">select ‘xxxx’ into outfile ‘&#x2F;tmp&#x2F;a.txt’</td></tr><tr><td align="left">ascii()</td><td align="center">字符串的ASCII代码值</td><td align="center">select ascii(‘a’)</td></tr><tr><td align="left">ord()</td><td align="center">返回字符串第一个字符的ASCII值</td><td align="center">select ord(‘abc’)</td></tr><tr><td align="left">char()</td><td align="center">返回ASCII值对应的字符串</td><td align="center">select char(97)</td></tr><tr><td align="left">mid()</td><td align="center">返回一个字符串的一部分</td><td align="center">select mid(‘abcde’,1,1)</td></tr><tr><td align="left">substr()</td><td align="center">返回一个字符串的一部分</td><td align="center">select substr(‘abcde’,1,1)</td></tr><tr><td align="left">length()</td><td align="center">返回字符串的长度</td><td align="center">select length(‘abc’)</td></tr><tr><td align="left">left()</td><td align="center">返回字符串最左面几个字符</td><td align="center">select left(‘mysql’,2)</td></tr><tr><td align="left">floor()</td><td align="center">返回小于或等于X的最大整数</td><td align="center">select floor(5.1)</td></tr><tr><td align="left">rand()</td><td align="center">返回0-1间的一个随机数</td><td align="center">select rand()</td></tr><tr><td align="left">if()</td><td align="center">三目运算</td><td align="center">select if(1&gt;2,’A’,’B’)</td></tr><tr><td align="left">strcmp()</td><td align="center">比较字符串ASCII大小</td><td align="center">select strcmp(‘c’,’b’)</td></tr><tr><td align="left">ifnull()</td><td align="center">参数1为不null则返回参数1,否则参数2</td><td align="center">select ifnull(null,2)</td></tr></tbody></table></blockquote><blockquote></blockquote><blockquote><ul><li>找表名:</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">?id=2&#x27; and 1=2 union select 1,group_concat(table_name),@@basedir from information_schema.tables where table_schema=&quot;security&quot;-- -</span><br><span class="line"></span><br><span class="line">2,3为回显位；</span><br><span class="line">union前必须为错才能执行union语句</span><br></pre></td></tr></table></figure><blockquote><ul><li>找字段名：</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=2&#x27; and 1=2 union select 1,group_concat(column_name),@@basedir from information_schema.columns where table_name=&quot;emails&quot;-- -</span><br><span class="line"></span><br><span class="line">爆emails表的列名</span><br></pre></td></tr></table></figure><blockquote><ul><li>爆记录：</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=2&#x27; and 1=2 union select 1,group_concat(id,email_id),3 from emails-- -</span><br><span class="line"></span><br><span class="line">选择需要的列爆记录</span><br></pre></td></tr></table></figure><blockquote><ul><li>查看内容：</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?id=2&#x27; and 1=2 union select 1,group_concat(id),group_concat(email_id) from emails-- -</span><br><span class="line"></span><br><span class="line">分开一一对应显示</span><br></pre></td></tr></table></figure><p>3.信息猜解(库名到表名列名到具体数据)</p><p>判断一个链接是否存在注入漏洞，可以通过对其传入的参数(但不仅仅只限于参数，还有cookie注入,HTTP头注入等)进行构造， 然后对服务器返回的内容进行判断来查看是否存在注入点。</p><p>注入点又分为有回显和无回显，有回显就是当我们输入恶意SQL语句时，页面会给我们一个反馈的信息,例如我们语句输入错误，后台就会把错误信息返回显示在网页上,而无回显就恰恰相反,当我们无论输入的SQL是正确或者错误，页面都不会发生改变。</p><h3 id="五、危害"><a href="#五、危害" class="headerlink" title="五、危害"></a>五、危害</h3><p>1.数据库信息泄露<br>数据库中存放的用户的隐私信息的泄露。</p><p>2.网页篡改<br>通过操作数据库对特定网页进行篡改。</p><p>3.网站被挂，传播恶意软件<br>修改数据库一些字段的值，嵌入链接，实行攻击。</p><p>4.数据库被恶意操作<br>数据库服务器被攻击，数据库的系统管理员账户被篡改。</p><p>5.服务器被远程控制<br>经由数据库服务器提供的操作系统支持，可以修改或者控制操作系统。</p><p>6.破坏硬盘数据，系统瘫痪</p><h3 id="六、注入应对方案"><a href="#六、注入应对方案" class="headerlink" title="六、注入应对方案"></a>六、注入应对方案</h3><p>1、参数过滤<br>参数过滤以各种厂商以及代码的WAF为主,比如替换空格,关键字,双写,大小写,特殊字符转义。<br>2、预编译<br>预编译主要依赖各种框架,比如Java的mybatis框架 和 PHP的 thinkphp框架。<br>3、限制权限和报错<br>限制权限和报错是指限制数据库的权限,以及控制数据库的报错信息,报错信息不要对外展示。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h2&gt;&lt;h3 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>SQL语句</title>
    <link href="http://example.com/2023/08/07/3/"/>
    <id>http://example.com/2023/08/07/3/</id>
    <published>2023-08-07T09:27:43.000Z</published>
    <updated>2023-08-11T02:26:47.177Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SQL基础"><a href="#1-SQL基础" class="headerlink" title="1. SQL基础"></a>1. SQL基础</h2><h4 id="1-1-数据库相关概念"><a href="#1-1-数据库相关概念" class="headerlink" title="1.1 数据库相关概念"></a>1.1 数据库相关概念</h4><p>数据库、数据库管理系统、SQL的概念。</p><p>  <img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808090307279.png" alt="image-20230808090307279"><br>目前主流的关系型数据库管理系统的市场占有率排名如下：<br><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808090745366.png" alt="image-20230808090745366"></p><p>Oracle：大型的收费数据库，Oracle公司产品，价格昂贵。<br>MySQL：开源免费的中小型数据库。 目前Oracle推出了收费版本的MySQL，也提供了免费的社区版本。<br>SQL Server：Microsoft 公司推出的收费的中型数据库，C#、.net等语言常用。<br>PostgreSQL：开源免费的中小型数据库。<br>DB2：IBM公司的大型收费数据库产品。<br>SQLLite：嵌入式的微型数据库。Android内置的数据库采用的就是该数据库。<br>MariaDB：开源免费的中小型数据库。是MySQL数据库的另外一个分支、另外一个衍生产品，与 MySQL数据库有很好的兼容性。</p><h5 id="关系型数据库与非关系型数据库"><a href="#关系型数据库与非关系型数据库" class="headerlink" title="关系型数据库与非关系型数据库"></a>关系型数据库与非关系型数据库</h5><p>一、概念<br>关系型数据库（RDBMS）<br>是建立在关系模型基础上，由多张相互连接的二维表组成的数据库。<br>而所谓二维表，指的是由行和列组成的表，如下图（就类似于Excel表格数据，有表头、有列、有行， 还可以通过一列关联另外一个表格中的某一列数据）。我们之前提到的MySQL、Oracle、DB2、 SQLServer这些都是属于关系型数据库，里面都是基于二维表存储数据的。<br>简单说，基于二维表存储 数据的数据库就成为关系型数据库，不是基于二维表存储数据的数据库，就是非关系型数据库。关系有一对一，一对多，多对多等。</p><p>非关系型数据库（NoSQL）<br>主要指那些非关系型的、分布式的，且一般不保证ACID的数据存储系统。<br>主要代表MongoDB，Redis、CouchDB。</p><p>NoSQL提出了另一种理念，以键值来存储，且结构不稳定，每一个元组都可以有不一样的字段，这种就不会局限于固定的结构，可以减少一些时间和空间的开销。使用这种方式，为了获取用户的不同信息，不需要像关系型数据库中，需要进行多表查询。仅仅需要根据key来取出对应的value值即可。</p><p>二、优缺点比较<br>关系型是结构化查询语言，NoSql是采用更简单而且精确的数据访问方式；SQl数据库大多比较昂贵，而NoSql大多是开源的。关系数据库安全系数高，容易理解，但比较浪费磁盘空间；非关系型数据库安全系数低但效率高。</p><p>目前许多大型互联网都会选用MySql+NoSql的组合方案，因为SQL和NoSql都有各自的优缺点。</p><p>关系型数据库适合存储结构化数据，比如：用户的账号、地址：</p><p>NoSql适合存储非结构化数据，比如：文章、评论：<br>这些数据通常用于模糊处理，例如全文搜索、机器学习，适合存储较为简单的数据。这些数据是海量的，并且增长的速度是难以预期的。</p><p>总结：</p><p>SQL数据库依然强大，可以可靠的处理事务并且保持事务的完整性，只有你的数据非常大，操作扩展需要更加分布式的系统时，才考虑NoSql数据库。</p><h4 id="1-2-客户端连接"><a href="#1-2-客户端连接" class="headerlink" title="1.2 客户端连接"></a>1.2 客户端连接</h4><p>使用系统自带的命令行工具执行指令<br>mysql [-h 127.0.0.1] [-P 3306] -u root -p<br><strong>注意： 使用这种方式进行连接时，需要安装完毕后配置PATH环境变量。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line">-h : MySQL服务所在的主机IP </span><br><span class="line">-P : MySQL服务端口号， 默认3306 </span><br><span class="line">-u : MySQL数据库用户名 </span><br><span class="line">-p ： MySQL数据库用户名对应的密码 </span><br><span class="line">[]内为可选参数，如果需要连接远程的MySQL，需要加上这两个参数来指定远程主机IP、端口，如果连接本地的MySQL，则无需指定这两个参数。</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808093509799.png" alt="image-20230808093509799"></p><h4 id="1-3-数据模型"><a href="#1-3-数据模型" class="headerlink" title="1.3 数据模型"></a>1.3 数据模型</h4><p>MySQL是关系型数据库，是基于二维表进行数据存储的，具体的结构图如下。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808094242678.png" alt="image-20230808094242678"></p><p>我们可以通过MySQL客户端连接数据库管理系统DBMS，然后通过DBMS操作数据库。<br>可以使用SQL语句，通过数据库管理系统操作数据库，以及操作数据库中的表结构及数据。<br>一个数据库服务器中可以创建多个数据库，一个数据库中也可以包含多张表，而一张表中又可以包含多行记录。</p><h2 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2. SQL"></a>2. SQL</h2><p>全称 Structured Query Language，结构化查询语言。操作关系型数据库的编程语言，定义了一套操作关系型数据库统一标准 。</p><h4 id="2-1-SQL通用语法"><a href="#2-1-SQL通用语法" class="headerlink" title="2.1 SQL通用语法"></a>2.1 SQL通用语法</h4><p>SQL语言的通用语法。<br>1). SQL语句可以单行或多行书写，以分号结尾。<br>2). SQL语句可以使用空格&#x2F;缩进来增强语句的可读性。<br>3). MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。<br>4). 注释：<br>单行注释：– 注释内容或 # 注释内容<br>多行注释：&#x2F;* 注释内容 *&#x2F;</p><h4 id="2-2-SQL分类"><a href="#2-2-SQL分类" class="headerlink" title="2.2 SQL分类"></a>2.2 SQL分类</h4><p>SQL语句的五种分类分别是DQL、DML、DDL、TCL和TCL。</p><p>1、数据库查询语言（DQL）<br>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE 子句组成的查询块，简称DQL，Data Query Language。代表关键字为select。</p><p>2、数据库操作语言（DML）<br>用户通过它可以实现对数据库的基本操作。简称DML，Data Manipulation Language。代表关键字为insert、delete 、update。</p><p>3、数据库定义语言（DDL）<br>数据定义语言DDL用来创建数据库中的各种对象，创建、删除、修改表的结构，比如表、视图、索引、同义词、聚簇等，简称DDL，Data Denifition Language。代表关键字为create、drop、alter。和DML相比，DML是修改数据库表中的数据，而 DDL 是修改数据中表的结构。</p><p>4、事务控制语言（TCL）<br>TCL经常被用于快速原型开发、脚本编程、GUI和测试等方面，简称：TCL，Trasactional Control Languag。代表关键字为commit、rollback。</p><p>5、数据控制语言（DCL）<br>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。简称：DCL，Data Control Language。代表关键字为grant、revoke。</p><h4 id="2-3-DDL"><a href="#2-3-DDL" class="headerlink" title="2.3 DDL"></a>2.3 DDL</h4><p>Data Definition Language，数据定义语言，用来定义数据库对象(数据库，表，字段) 。 </p><p>1). 查询所有数据库</p><blockquote><p>show databases ; </p></blockquote><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808101813071.png" alt="image-20230808101813071"></p><p>2). 查询当前数据库</p><blockquote><p>select database() ; </p></blockquote><p>3). 创建数据库<br>create database [ if not exists ] 数据库名 [ default charset 字符集 ] [ collate 排序规则 ] ;  </p><p>在同一个数据库服务器中，不能创建两个名称相同的数据库，否则将会报错。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808101905210.png" alt="image-20230808101905210"></p><p>可以通过if not exists 参数来解决这个问题，数据库不存在, 则创建该数据库，如果存在，则不创建。<br>create database if not extists itcast; </p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808102016421.png" alt="image-20230808102016421"></p><p>创建一个itheima数据库，并且指定字符集<br>create database itheima default charset utf8mb4; </p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808102402653.png" alt="image-20230808102402653"></p><p>4). 删除数据库</p><blockquote><p>drop database [ if exists ] 数据库名 ; </p></blockquote><p>如果删除一个不存在的数据库，将会报错。此时，可以加上参数 if exists ，如果数据库存在，再执行删除，否则不执行删除。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808102426133.png" alt="image-20230808102426133"></p><p>5). 切换数据库</p><p>use 数据库名 ; 我们要操作某一个数据库下的表时，就需要通过该指令，切换到对应的数据库下，否则是不能操作的。<br>比如，切换到itcast数据，执行如下SQL：</p><blockquote><p>use itcast; </p></blockquote><h4 id="2-4-表操作"><a href="#2-4-表操作" class="headerlink" title="2.4 表操作"></a>2.4 表操作</h4><h5 id="2-4-1表操作-查询创建"><a href="#2-4-1表操作-查询创建" class="headerlink" title="2.4.1表操作-查询创建"></a>2.4.1表操作-查询创建</h5><p>1). 查询当前数据库所有表<br>show tables;<br>比如,我们可以切换到sys这个系统数据库,并查看系统数据库中的所有表结构。<br>use sys;<br>show tables;</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808102839785.png" alt="image-20230808102839785"></p><p>2). 查看指定表结构<br>desc 表名 ;<br>通过这条指令，我们可以查看到指定表的字段，字段的类型、是否可以为NULL，是否存在默认值等信息。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808102859501.png" alt="image-20230808102859501"></p><p>3). 查询指定表的建表语句<br>show create table 表名 ;<br>通过这条指令，主要是用来查看建表语句的，而有部分参数我们在创建表的时候，并未指定也会查询到，因为这部分是数据库的默认值，如：存储引擎、字符集等。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808103046292.png" alt="image-20230808103046292"></p><p>4). 创建表结构<br>CREATE TABLE 表名(<br>字段1 字段1类型 [ COMMENT 字段1注释 ],<br>字段2 字段2类型 [COMMENT 字段2注释 ],<br>字段3 字段3类型 [COMMENT 字段3注释 ],<br>……<br>字段n 字段n类型 [COMMENT 字段n注释 ]<br>) [ COMMENT 表注释 ] ;<br>注意: […] 内为可选参数，最后一个字段后面没有逗号<br>比如，我们创建一张表 tb_user ，对应的结构如下，那么建表语句为：</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808103145129.png" alt="image-20230808103145129"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table tb_user( </span><br><span class="line">id int comment &#x27;编号&#x27;, </span><br><span class="line">name varchar(50) comment &#x27;姓名&#x27;, </span><br><span class="line">age int comment &#x27;年龄&#x27;, </span><br><span class="line">gender varchar(1) comment &#x27;性别&#x27; </span><br><span class="line">) comment &#x27;用户表&#x27;; </span><br></pre></td></tr></table></figure><h5 id="2-4-2表操作-数据类型"><a href="#2-4-2表操作-数据类型" class="headerlink" title="2.4.2表操作-数据类型"></a>2.4.2表操作-数据类型</h5><p>在上述的建表语句中，我们在指定字段的数据类型时，用到了int ，varchar，MySQL中除以上的数据类型，还有其他的数据类型。主要分为三类：数值类型、字符串类型、日期时间类型。<br>1）数值类型</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808103843769.png" alt="image-20230808103843769"></p><p>2）字符串类型</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808103858701.png" alt="image-20230808103858701"></p><p>3）日期时间类型</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808103915176.png" alt="image-20230808103915176"></p><h5 id="2-4-3-表操作-修改"><a href="#2-4-3-表操作-修改" class="headerlink" title="2.4.3 表操作-修改"></a>2.4.3 表操作-修改</h5><p>1). 添加字段<br>ALTER TABLE 表名 ADD 字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];<br>案例<br>为emp表增加一个新的字段”昵称”为nickname，类型为varchar(20)<br>ALTER TABLE emp ADD nickname varchar(20) COMMENT ‘昵称’; </p><p>2). 修改数据类型<br>ALTER TABLE 表名 MODIFY 字段名 新数据类型 (长度); </p><p>3). 修改字段名和字段类型<br>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型 (长度) [ COMMENT 注释 ] [ 约束 ];<br>案例:<br>将emp表的nickname字段修改为username，类型为varchar(30)<br>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT ‘昵称’; </p><p>4). 删除字段<br>ALTER TABLE 表名 DROP 字段名;<br>案例:<br>将emp表的字段username删除<br>ALTER TABLE emp DROP username; </p><p>5). 修改表名<br>ALTER TABLE 表名 RENAME TO 新表名;<br>案例:<br>将emp表的表名修改为 employee<br>ALTER TABLE emp RENAME TO employee; </p><h5 id="2-4-6-表操作-删除"><a href="#2-4-6-表操作-删除" class="headerlink" title="2.4.6 表操作-删除"></a>2.4.6 表操作-删除</h5><p>1). 删除表<br>DROP TABLE [ IF EXISTS ] 表名;<br>可选项 IF EXISTS 代表，只有表名存在时才会删除该表，表名不存在，则不执行删除操作(如果不加该参数项，删除一张不存在的表，执行将会报错)。<br>案例:<br>如果tb_user表存在，则删除tb_user表<br>DROP TABLE IF EXISTS tb_user;<br>2). 删除指定表, 并重新创建表<br>TRUNCATE TABLE 表名;<br>注意: 在删除表的时候，表中的全部数据也都会被删除。</p><h4 id="2-5-图形化界面工具"><a href="#2-5-图形化界面工具" class="headerlink" title="2.5 图形化界面工具"></a>2.5 图形化界面工具</h4><p>上述，我们已经讲解了通过DDL语句，如何操作数据库、操作表、操作表中的字段，而通过DDL语句执行在命令进行操作，主要存在以下两点问题：<br>1).会影响开发效率 ;<br>2). 使用起来，并不直观，并不方便 ；<br>所以呢，我们在日常的开发中，会借助于MySQL的图形化界面，来简化开发，提高开发效率。navicat是其中一种，使用navicat能让我们更方便地进行数据库操作。</p><h4 id="2-6-DML"><a href="#2-6-DML" class="headerlink" title="2.6 DML"></a>2.6 DML</h4><p>DML英文全称是Data Manipulation Language(数据操作语言)，用来对数据库中表的数据记录进行增、删、改操作。<br>添加数据（INSERT）<br>修改数据（UPDATE）<br>删除数据（DELETE） </p><h5 id="2-6-1-添加数据"><a href="#2-6-1-添加数据" class="headerlink" title="2.6.1 添加数据"></a>2.6.1 添加数据</h5><p>1). 给指定字段添加数据<br>INSERT INTO 表名 (字段名1, 字段名2, …) VALUES (值1, 值2, …);<br>1案例: 给employee表所有的字段添加数据 ；<br>插入数据完成之后，我们有两种方式，查询数据库的数据：<br>A. 方式一<br>在左侧的表名上双击，就可以查看这张表的数据</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808104744589.png" alt="image-20230808104744589"></p><p>B. 方式二<br>可以直接一条查询数据的SQL语句, 语句如下:<br>select * from employee;<br>案例: 给employee表所有的字段添加数据<br>执行如下SQL，添加的年龄字段值为3。<br>insert into employee(id,workno,name,gender,age,idcard,entrydate)<br>values(1,’1’,’Itcast’,’男’,3,’123456789012345678’,’2000-01-01’); </p><p>2). 给全部字段添加数据<br>INSERT INTO 表名 VALUES (值1, 值2, …);<br>案例：插入数据到employee表，具体的SQL如下：<br>insert into employee values(2,’2’,’张无忌’,’男’,18,’123456789012345670’,’2005-01- 01’);<br>3). 批量添加数据<br>INSERT INTO 表名 (字段名1, 字段名2, …) VALUES (值1, 值2, …), (值1, 值2, …), (值 1, 值2, …);<br>INSERT INTO 表名 VALUES (值1, 值2, …), (值1, 值2, …), (值1, 值2, …) ;<br>案例：批量插入数据到employee表，具体的SQL如下：<br>insert into employee values(3,’3’,’韦一笑’,’男’,38,’123456789012345670’,’2005-01- 01’),(4,’4’,’赵敏’,’女’,18,’123456789012345670’,’2005-01-01’); </p><p>**注意事项: **</p><blockquote><ul><li>插入数据时，指定的字段顺序需要与值的顺序是一一对应的。</li><li>字符串和日期型数据应该包含在引号中。 </li><li>插入的数据大小，应该在字段的规定范围内。</li></ul></blockquote><h5 id="2-6-2-修改数据"><a href="#2-6-2-修改数据" class="headerlink" title="2.6.2 修改数据"></a>2.6.2 修改数据</h5><p>修改数据的具体语法为:<br>UPDATE 表名 SET 字段名1 &#x3D; 值1 , 字段名2 &#x3D; 值2 , …. [ WHERE 条件 ] ;<br>案例:<br>A. 修改id为1的数据，将name修改为itheima<br>update employee set name &#x3D; ‘itheima’ where id &#x3D; 1;<br>B. 修改id为1的数据, 将name修改为小昭, gender修改为 女<br>update employee set name &#x3D; ‘小昭’ , gender &#x3D; ‘女’ where id &#x3D; 1;<br>C. 将所有的员工入职日期修改为 2008-01-01<br>update employee set entrydate &#x3D; ‘2008-01-01’;<br>注意事项:<br>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。</p><h5 id="2-6-3-删除数据"><a href="#2-6-3-删除数据" class="headerlink" title="2.6.3 删除数据"></a>2.6.3 删除数据</h5><p>删除数据的具体语法为：<br>DELETE FROM 表名 [ WHERE 条件 ] ;<br>案例:<br>A. 删除gender为女的员工<br>delete from employee where gender &#x3D; ‘女’;<br>B. 删除所有员工<br>delete from employee;</p><p>**注意事项: **</p><blockquote><ul><li>DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。 </li><li>DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。 </li><li>当进行删除全部数据操作时，datagrip会提示我们，询问是否确认删除，我们直接点击<br>Execute即可。</li></ul></blockquote><h4 id="2-7-DQL"><a href="#2-7-DQL" class="headerlink" title="2.7 DQL"></a>2.7 DQL</h4><p>DQL英文全称是Data Query Language(数据查询语言)，数据查询语言，用来查询数据库中表的记录。<br>查询关键字: SELECT<br>在一个正常的业务系统中，查询操作的频次是要远高于增删改的，当我们去访问企业官网、电商网站，<br>在这些网站中我们所看到的数据，实际都是需要从数据库中查询并展示的。而且在查询的过程中，可能还会涉及到条件、排序、分页等操作。</p><h5 id="2-7-1-基础查询"><a href="#2-7-1-基础查询" class="headerlink" title="2.7.1 基础查询"></a>2.7.1 基础查询</h5><p>在基本查询的DQL语句中，不带任何的查询条件，查询的语法如下：<br>1). 查询多个字段<br>SELECT 字段1, 字段2, 字段3 … FROM 表名 ;<br>SELECT * FROM 表名 ;<br>注意 : * 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。<br>2). 字段设置别名<br>SELECT 字段1 [ AS 别名1 ] , 字段2 [ AS 别名2 ] … FROM 表名;<br>SELECT 字段1 [ 别名1 ] , 字段2 [ 别名2 ] … FROM 表名;<br>3). 去除重复记录<br>SELECT DISTINCT 字段列表 FROM 表名;<br>案例：<br>A. 查询指定字段 name, workno, age并返回<br>select name,workno,age from emp;<br>B. 查询返回所有字段<br>select id ,workno,name,gender,age,idcard,workaddress,entrydate from emp;<br>select * from emp;<br>C. 查询所有员工的工作地址,起别名<br>select workaddress as ‘工作地址’ from emp;<br>– as可以省略<br>select workaddress ‘工作地址’ from emp;<br>D. 查询公司员工的上班地址有哪些(不要重复)<br>select distinct workaddress ‘工作地址’ from emp; </p><h5 id="2-7-2-条件查询"><a href="#2-7-2-条件查询" class="headerlink" title="2.7.2 条件查询"></a>2.7.2 条件查询</h5><p>1). 语法<br>SELECT 字段列表 FROM 表名 WHERE 条件列表 ;<br>2). 条件<br>比较运算符、逻辑运算符。</p><p>案例:<br>A. 查询年龄等于 88 的员工<br>select * from emp where age &#x3D; 88;<br>B. 查询年龄小于 20 的员工信息<br>select * from emp where age &lt; 20;<br>C. 查询年龄小于等于 20 的员工信息<br>select * from emp where age &lt;&#x3D; 20;<br>D. 查询没有身份证号的员工信息<br>select * from emp where idcard is null;<br>F. 查询年龄不等于 88 的员工信息<br>select * from emp where age !&#x3D; 88;<br>select * from emp where age &lt;&gt; 88;<br>G. 查询年龄在15岁(包含) 到 20岁(包含)之间的员工信息<br>select * from emp where age &gt;&#x3D; 15 &amp;&amp; age &lt;&#x3D; 20;<br>select * from emp where age &gt;&#x3D; 15 and age &lt;&#x3D; 20;<br>select * from emp where age between 15 and 20;<br>H. 查询性别为 女 且年龄小于 25岁的员工信息<br>select * from emp where gender &#x3D; ‘女’ and age &lt; 25;<br>I. 查询年龄等于18 或 20 或 40 的员工信息<br>select * from emp where age &#x3D; 18 or age &#x3D; 20 or age &#x3D;40;<br>select * from emp where age in(18,20,40);<br>J. 查询姓名为两个字的员工信息 _ %<br>select * from emp where name like ‘__’;<br>K. 查询身份证号最后一位是X的员工信息<br>select * from emp where idcard like ‘%X’; </p><h5 id="2-7-3-聚合函数"><a href="#2-7-3-聚合函数" class="headerlink" title="2.7.3 聚合函数"></a>2.7.3 聚合函数</h5><p>1). 介绍<br>将一列数据作为一个整体，进行纵向计算 。<br>2). 常见的聚合函数</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808110226295.png" alt="image-20230808110226295"><br>3). 语法<br>SELECT 聚合函数(字段列表) FROM 表名 ;<br>注意 : NULL值是不参与所有聚合函数运算的。<br>案例：<br>A. 统计该企业员工数量<br>select count(*) from emp; – 统计的是总记录数<br>select count(idcard) from emp; – 统计的是idcard字段不为null的记录数<br>对于count聚合函数，统计符合条件的总记录数，还可以通过 count(数字&#x2F;字符串)的形式进行统计查询，比如：<br>select count(1) from emp; </p><p>B. 统计该企业员工的平均年龄<br>select avg(age) from emp; </p><p>C. 统计该企业员工的最大年龄<br>select max(age) from emp;</p><p>D. 统计该企业员工的最小年龄<br>select min(age) from emp; </p><p>E. 统计西安地区员工的年龄之和<br>select sum(age) from emp where workaddress &#x3D; ‘西安’; </p><h5 id="2-7-4-分组查询"><a href="#2-7-4-分组查询" class="headerlink" title="2.7.4 分组查询"></a>2.7.4 分组查询</h5><p>1). 语法<br>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组 后过滤条件 ];<br>2). where与having区别<br>执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。 </p><p>**注意事项: **</p><blockquote><ul><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。 </li><li>执行顺序: where &gt; 聚合函数 &gt; having 。 </li><li>支持多字段分组, 具体语法为 : group by columnA,columnB</li></ul></blockquote><p>案例:<br>A. 根据性别分组 , 统计男性员工 和 女性员工的数量<br>select gender, count(<em>) from emp group by gender ;<br>B. 根据性别分组 , 统计男性员工 和 女性员工的平均年龄<br>select gender, avg(age) from emp group by gender ;<br>C. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址<br>select workaddress, count(</em>) address_count from emp where age &lt; 45 group by workaddress having address_count &gt;&#x3D; 3;<br>D. 统计各个工作地址上班的男性及女性员工的数量<br>select workaddress, gender, count(*) ‘数量’ from emp group by gender , workaddress; </p><h5 id="2-7-5-排序查询"><a href="#2-7-5-排序查询" class="headerlink" title="2.7.5 排序查询"></a>2.7.5 排序查询</h5><p>排序在日常开发中是非常常见的一个操作，有升序排序，也有降序排序。</p><p>1). 语法<br>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1 , 字段2 排序方式2 ;<br>2). 排序方式<br>ASC : 升序(默认值)<br>DESC: 降序<br>注意事项：<br>• 如果是升序, 可以不指定排序方式ASC ;<br>• 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;<br>案例:<br>A. 根据年龄对公司的员工进行升序排序<br>select * from emp order by age asc;<br>select * from emp order by age;<br>B. 根据入职时间, 对员工进行降序排序<br>select * from emp order by entrydate desc;<br>C. 根据年龄对公司的员工进行升序排序 , 年龄相同 , 再按照入职时间进行降序排序<br>select * from emp order by age asc , entrydate desc;</p><h5 id="2-7-6-分页查询"><a href="#2-7-6-分页查询" class="headerlink" title="2.7.6 分页查询"></a>2.7.6 分页查询</h5><p>分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台都需要借助于数据库的分页操作。</p><p>1). 语法<br>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;<br>注意事项:<br>• 起始索引从0开始，起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数。<br>• 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。<br>• 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10<br>案例:<br>A. 查询第1页员工数据, 每页展示10条记录<br>select * from emp limit 0,10;<br>select * from emp limit 10;<br>B. 查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数<br>select * from emp limit 10,10; </p><h5 id="2-7-7-案例"><a href="#2-7-7-案例" class="headerlink" title="2.7.7 案例"></a>2.7.7 案例</h5><p>1). 查询年龄为20,21,22,23岁的员工信息。<br>select * from emp where gender &#x3D; ‘女’ and age in(20,21,22,23);<br>2). 查询性别为 男 ，并且年龄在 20-40 岁(含)以内的姓名为三个字的员工。<br>select * from emp where gender &#x3D; ‘男’ and ( age between 20 and 40 ) and name like’___’; </p><p>3). 统计员工表中, 年龄小于60岁的 , 男性员工和女性员工的人数<br>select gender, count(*) from emp where age &lt; 60 group by gender; </p><p>4). 查询所有年龄小于等于35岁员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序。<br>select name , age from emp where age &lt;&#x3D; 35 order by age asc , entrydate desc;</p><p>5). 查询性别为男，且年龄在20-40 岁(含)以内的前5个员工信息，对查询的结果按年龄升序排序,年龄相同按入职时间升序排序。<br>select * from emp where gender &#x3D; ‘男’ and age between 20 and 40 order by age asc ,<br>entrydate asc limit 5 ; </p><h5 id="2-7-8-执行顺序"><a href="#2-7-8-执行顺序" class="headerlink" title="2.7.8 执行顺序"></a>2.7.8 执行顺序</h5><p>DQL语句在执行时的执行顺序，也就是先执行哪一部分，后执行哪一部分。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808111020433.png" alt="image-20230808111020433"></p><h4 id="2-8-DCL"><a href="#2-8-DCL" class="headerlink" title="2.8 DCL"></a>2.8 DCL</h4><p>DCL英文全称是Data Control Language(数据控制语言)，用来管理数据库用户、控制数据库的访问权限。</p><h5 id="2-8-1-管理用户"><a href="#2-8-1-管理用户" class="headerlink" title="2.8.1 管理用户"></a>2.8.1 管理用户</h5><p>1). 查询用户<br>select * from mysql.user;<br>查询的结果如下:</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808112411681.png" alt="image-20230808112411681"></p><p>其中 Host代表当前用户访问的主机, 如果为localhost, 仅代表只能够在当前本机访问，是不可以远程访问的。 User代表的是访问该数据库的用户名。在MySQL中需要通过Host和User来唯一标识一个用户。<br>2). 创建用户<br>CREATE USER ‘用户名‘@’主机名’ IDENTIFIED BY ‘密码’;<br>3). 修改用户密码<br>ALTER USER ‘用户名‘@’主机名’ IDENTIFIED WITH mysql_native_password BY ‘新密码’ ;<br>4). 删除用户<br>DROP USER ‘用户名‘@’主机名’ ;<br>注意事项: </p><blockquote><ul><li>在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。</li><li>主机名可以使用 % 通配。 </li><li>这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库 管理员）使用。</li></ul></blockquote><p>案例：<br>A. 创建用户itcast, 只能够在当前主机localhost访问, 密码123456<br>create user ‘itcast‘@’localhost’ identified by ‘123456’;<br>B. 创建用户heima, 可以在任意主机访问该数据库, 密码123456;<br>create user ‘heima‘@’%’ identified by ‘123456’;<br>C. 修改用户heima的访问密码为1234;<br>alter user ‘heima‘@’%’ identified with mysql_native_password by ‘1234’;<br>D. 删除 itcast@localhost 用户<br>drop user ‘itcast‘@’localhost’; </p><h6 id="2-8-2-权限控制"><a href="#2-8-2-权限控制" class="headerlink" title="2.8.2 权限控制"></a>2.8.2 权限控制</h6><p>MySQL中定义了很多种权限，但是常用的就以下几种：</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808112436818.png" alt="image-20230808112436818"></p><p>上述只是简单罗列了常见的几种权限描述，其他权限描述及含义，可以直接参考官方文档。<br>1). 查询权限<br>SHOW GRANTS FOR ‘用户名‘@’主机名’ ;<br>2). 授予权限<br>GRANT 权限列表 ON 数据库名.表名 TO ‘用户名‘@’主机名’;<br>3). 撤销权限<br>REVOKE 权限列表 ON 数据库名.表名 FROM ‘用户名‘@’主机名’;</p><p>注意事项： </p><blockquote><ul><li>多个权限之间，使用逗号分隔 </li><li>授权时， 数据库名和表名可以使用 * 进行通配，代表所有。</li></ul></blockquote><p>案例:<br>A. 查询 ‘heima‘@’%’ 用户的权限<br>show grants for ‘heima‘@’%’;<br>B. 授予 ‘heima‘@’%’ 用户itcast数据库所有表的所有操作权限<br>grant all on itcast.* to ‘heima‘@’%’;<br>C. 撤销 ‘heima‘@’%’ 用户的itcast数据库的所有权限<br>revoke all on itcast.* from ‘heima‘@’%’; </p><h5 id="2-8-3-函数"><a href="#2-8-3-函数" class="headerlink" title="2.8.3.函数"></a>2.8.3.函数</h5><p>函数 是指一段可以直接被另一段程序调用的程序或代码。MySQL中的函数主要分为以下四类： 字符串函数、数值函数、日期函数、流程函数。<br>1） 字符串函数<br>MySQL中内置了很多字符串函数，常用的几个如下：</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808112510202.png" alt="image-20230808112510202"></p><p>演示如下：<br>A. concat : 字符串拼接<br>select concat(‘Hello’ , ‘ MySQL’);<br>B. lower : 全部转小写<br>select lower(‘Hello’);<br>C. upper : 全部转大写<br>select upper(‘Hello’);<br>D. lpad : 左填充<br>select lpad(‘01’, 5, ‘-‘);<br>E. rpad : 右填充<br>select rpad(‘01’, 5, ‘-‘);<br>F. trim : 去除空格<br>select trim(‘ Hello MySQL ‘);<br>G. substring : 截取子字符串<br>select substring(‘Hello MySQL’,1,5);<br>案例:</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808112536566.png" alt="image-20230808112536566"></p><p>由于业务需求变更，企业员工的工号，统一为5位数，目前不足5位数的全部在前面补0。比如： 1号员<br>工的工号应该为00001<br>update emp set workno &#x3D; lpad(workno, 5, ‘0’);<br>处理完毕后, 具体的数据为: </p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808112557507.png" alt="image-20230808112557507"></p><p>2） 数值函数<br>常见的数值函数如下：</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808112615000.png" alt="image-20230808112615000"></p><p>演示如下：<br>A. ceil：向上取整<br>select ceil(1.1);<br>B. floor：向下取整<br>select floor(1.9);<br>C. mod：取模<br>select mod(7,4);<br>D. rand：获取随机数<br>select rand();<br>E. round：四舍五入<br>select round(2.344,2);<br>案例：<br>通过数据库的函数，生成一个六位数的随机验证码。<br>思路： 获取随机数可以通过rand()函数，但是获取出来的随机数是在0-1之间的，所以可以在其基础上乘以1000000，然后舍弃小数部分，如果长度不足6位，补0<br>select lpad(round(rand()*1000000 , 0), 6, ‘0’);</p><p>3） 日期函数<br>常见的日期函数如下：</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808112630382.png" alt="image-20230808112630382"></p><p>演示如下：<br>A. curdate：当前日期<br>select curdate();<br>B. curtime：当前时间<br>select curtime();<br>C. now：当前日期和时间<br>select now();<br>D. YEAR , MONTH , DAY：当前年、月、日<br>select YEAR(now());<br>select MONTH(now());<br>select DAY(now());<br>E. date_add：增加指定的时间间隔<br>select date_add(now(), INTERVAL 70 YEAR );<br>F. datediff：获取两个日期相差的天数<br>select datediff(‘2021-10-01’, ‘2021-12-01’); </p><p>案例：<br>查询所有员工的入职天数，并根据入职天数倒序排序。<br>思路： 入职天数，就是通过当前日期 - 入职日期，所以需要使用datediff函数来完成。<br>select name, datediff(curdate(), entrydate) as ‘entrydays’ from emp order by entrydays desc; </p><h4 id="3-1-流程函数"><a href="#3-1-流程函数" class="headerlink" title="3.1 流程函数"></a>3.1 流程函数</h4><p>流程函数也是很常用的一类函数，可以在SQL语句中实现条件筛选，从而提高语句的效率。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230808112650367.png" alt="image-20230808112650367"></p><p>演示如下：<br>A. if<br>select if(false, ‘Ok’, ‘Error’);<br>B. ifnull<br>select ifnull(‘Ok’,’Default’);<br>select ifnull(‘’,’Default’);<br>select ifnull(null,’Default’);<br>C. case when then else end<br>需求: 查询emp表的员工姓名和工作地址 (北京&#x2F;上海 —-&gt; 一线城市 , 其他 —-&gt; 二线城市)<br>select name , ( case workaddress when ‘北京’ then ‘一线城市’ when ‘上海’ then ‘一线城市’ else ‘二线城市’ end ) as ‘工作地址’ from emp;<br>案例:<br>create table score(<br>id int comment ‘ID’,<br>name varchar(20) comment ‘姓名’,<br>math int comment ‘数学’,<br>english int comment ‘英语’,<br>chinese int comment ‘语文’<br>) comment ‘学员成绩表’;<br>insert into score(id, name, math, english, chinese) VALUES (1, ‘Tom’, 67, 88, 95 ), (2, ‘Rose’ , 23, 66, 90),(3, ‘Jack’, 56, 98, 76);<br>具体的SQL语句如下:<br>select id , name,<br>(case when math &gt;&#x3D; 85 then ‘优秀’ when math &gt;&#x3D;60 then ‘及格’ else ‘不及格’ end )<br>‘数学’,<br>(case when english &gt;&#x3D; 85 then ‘优秀’ when english &gt;&#x3D;60 then ‘及格’ else ‘不及格’<br>end ) ‘英语’,<br>(case when chinese &gt;&#x3D; 85 then ‘优秀’ when chinese &gt;&#x3D;60 then ‘及格’ else ‘不及格’<br>end ) ‘语文’<br>from score;<br>MySQL的常见函数我们学习完了，那接下来，我们就来分析一下，在前面讲到的两个函数的案例场景，<br>思考一下需要用到什么样的函数来实现?<br>1). 数据库中，存储的是入职日期，如 2000-01-01，如何快速计算出入职天数呢？ ——–&gt;<br>答案: datediff<br>2). 数据库中，存储的是学生的分数值，如98、75，如何快速判定分数的等级呢？ ———-&gt;<br>答案: case … when …</p><h4 id="3-2约束"><a href="#3-2约束" class="headerlink" title="3.2约束"></a>3.2约束</h4><h5 id="3-2-1-概述"><a href="#3-2-1-概述" class="headerlink" title="3.2.1 概述"></a>3.2.1 概述</h5><p>概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。<br>目的：保证数据库中数据的正确、有效性和完整性。<br>分类</p><p>注意：约束是作用于表中字段上的，可以在创建表&#x2F;修改表的时候添加约束。</p><h5 id="3-2-2-约束演示"><a href="#3-2-2-约束演示" class="headerlink" title="3.2.2 约束演示"></a>3.2.2 约束演示</h5><p>上面我们介绍了数据库中常见的约束，以及约束涉及到的关键字，那这些约束我们到底如何在创建表、<br>修改表的时候来指定呢，接下来我们就通过一个案例，来演示一下。<br>案例需求： 根据需求，完成表结构的创建。需求如下：</p><p>对应的建表语句为：<br>CREATE TABLE tb_user(<br>id int AUTO_INCREMENT PRIMARY KEY COMMENT ‘ID唯一标识’,<br>name varchar(10) NOT NULL UNIQUE COMMENT ‘姓名’ ,<br>age int check (age &gt; 0 &amp;&amp; age &lt;&#x3D; 120) COMMENT ‘年龄’ ,<br>status char(1) default ‘1’ COMMENT ‘状态’,<br>gender char(1) COMMENT ‘性别’<br>);<br>在为字段添加约束时，我们只需要在字段之后加上约束的关键字即可，需要关注其语法。我们执行上面的SQL把表结构创建完成，然后接下来，就可以通过一组数据进行测试，从而验证一下，约束是否可以生效。<br>insert into tb_user(name,age,status,gender) values (‘Tom1’,19,’1’,’男’),<br>(‘Tom2’,25,’0’,’男’);<br>insert into tb_user(name,age,status,gender) values (‘Tom3’,19,’1’,’男’);<br>insert into tb_user(name,age,status,gender) values (null,19,’1’,’男’);<br>insert into tb_user(name,age,status,gender) values (‘Tom3’,19,’1’,’男’);<br>insert into tb_user(name,age,status,gender) values (‘Tom4’,80,’1’,’男’);<br>insert into tb_user(name,age,status,gender) values (‘Tom5’,-1,’1’,’男’);<br>insert into tb_user(name,age,status,gender) values (‘Tom5’,121,’1’,’男’);<br>insert into tb_user(name,age,gender) values (‘Tom5’,120,’男’);<br>上面，我们是通过编写SQL语句的形式来完成约束的指定，那加入我们是通过图形化界面来创建表结构时，又该如何来指定约束呢？ 只需要在创建表的时候，根据我们的需要选择对应的约束即可。</p><h5 id="3-2-3-外键约束"><a href="#3-2-3-外键约束" class="headerlink" title="3.2.3 外键约束"></a>3.2.3 外键约束</h5><p>1） 介绍<br>外键：用来让两张表的数据之间建立连接，从而保证数据的一致性和完整性。<br>我们来看一个例子：</p><p>左侧的emp表是员工表，里面存储员工的基本信息，包含员工的ID、姓名、年龄、职位、薪资、入职日期、上级主管ID、部门ID，在员工的信息中存储的是部门的ID dept_id，而这个部门的ID是关联的部门表dept的主键id，那emp表的dept_id就是外键,关联的是另一张表的主键。<br>注意：目前上述两张表，只是在逻辑上存在这样一层关系；在数据库层面，并未建立外键关联，所以是无法保证数据的一致性和完整性的<br>没有数据库外键关联的情况下，能够保证一致性和完整性呢，我们来测试一下。<br>准备数据<br>create table dept(<br>id int auto_increment comment ‘ID’ primary key,<br>name varchar(50) not null comment ‘部门名称’ )comment ‘部门表’;<br>INSERT INTO dept (id, name) VALUES (1, ‘研发部’), (2, ‘市场部’),(3, ‘财务部’), (4, ‘销售部’), (5, ‘总经办’);<br>create table emp(<br>id int auto_increment comment ‘ID’ primary key,<br>name varchar(50) not null comment ‘姓名’,<br>age int comment ‘年龄’,<br>job varchar(20) comment ‘职位’,<br>salary int comment ‘薪资’,<br>entrydate date comment ‘入职时间’,<br>managerid int comment ‘直属领导ID’,<br>dept_id int comment ‘部门ID’<br>)comment ‘员工表’;<br>INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id) VALUES<br>(1, ‘金庸’, 66, ‘总裁’,20000, ‘2000-01-01’, null,5),(2, ‘张无忌’, 20, ‘项目经理’,12500, ‘2005-12-05’, 1,1),<br>(3, ‘杨逍’, 33, ‘开发’, 8400,’2000-11-03’, 2,1),(4, ‘韦一笑’, 48, ‘开发’,11000, ‘2002-02-05’, 2,1),<br>(5, ‘常遇春’, 43, ‘开发’,10500, ‘2004-09-07’, 3,1),(6, ‘小昭’, 19, ‘程序员鼓励师’,6600, ‘2004-10-12’, 2,1); </p><p>接下来，我们可以做一个测试，删除id为1的部门信息。</p><p>结果，我们看到删除成功，而删除成功之后，部门表不存在id为1的部门，而在emp表中还有很多的员工，关联的为id为1的部门，此时就出现了数据的不完整性。 而要想解决这个问题就得通过数据库的外键约束。</p><h5 id="3-2-4-语法"><a href="#3-2-4-语法" class="headerlink" title="3.2.4 语法"></a>3.2.4 语法</h5><p>1). 添加外键<br>CREATE TABLE 表名(<br>字段名 数据类型,<br>…<br>[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名));<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ;<br>案例:<br>为emp表的dept_id字段添加外键约束,关联dept表的主键id。<br>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references<br>dept(id); </p><p>添加了外键约束之后，我们再到dept表(父表)删除id为1的记录，然后看一下会发生什么现象。 此时将会报错，不能删除或更新父表记录，因为存在外键约束。</p><p>2). 删除外键<br>ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;<br>案例：<br>删除emp表的外键fk_emp_dept_id。<br>alter table emp drop foreign key fk_emp_dept_id; </p><h5 id="3-2-3-删除-更新行为"><a href="#3-2-3-删除-更新行为" class="headerlink" title="3.2.3 删除&#x2F;更新行为"></a>3.2.3 删除&#x2F;更新行为</h5><p>添加了外键之后，再删除父表数据时产生的约束行为，我们就称为删除&#x2F;更新行为。具体的删除&#x2F;更新行为有以下几种:</p><p>具体语法为:<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES<br>主表名 (主表字段名) ON UPDATE CASCADE ON DELETE CASCADE;<br>演示如下：<br>由于NO ACTION 是默认行为，我们前面语法演示的时候，已经测试过了，就不再演示了，这里我们再演示其他的两种行为：CASCADE、SET NULL。<br>1). CASCADE<br>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade ;<br>A. 修改父表id为1的记录，将id修改为6</p><p>我们发现，原来在子表中dept_id值为1的记录，现在也变为6了，这就是cascade级联的效果。<br>在一般的业务系统中，不会修改一张表的主键值<br>B. 删除父表id为6的记录</p><p>我们发现，父表的数据删除成功了，但是子表中关联的记录也被级联删除了。<br>2). SET NULL<br>在进行测试之前，我们先需要删除上面建立的外键 fk_emp_dept_id。然后再通过数据脚本，将emp、dept表的数据恢复了。<br>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references<br>dept(id) on update set null on delete set null ;<br>接下来，我们删除id为1的数据，看看会发生什么样的现象。</p><p>我们发现父表的记录是可以正常的删除的，父表的数据删除之后，再打开子表 emp，我们发现子表emp的dept_id字段，原来dept_id为1的数据，现在都被置为NULL了。</p><p>这就是SET NULL这种删除&#x2F;更新行为的效果。</p><h2 id="4-多表查询"><a href="#4-多表查询" class="headerlink" title="4 多表查询"></a>4 多表查询</h2><p>我们之前在讲解SQL语句的时候，讲解了DQL语句，也就是数据查询语句，但是之前讲解的查询都是单表查询，而本章节我们要学习的则是多表查询操作，主要从以下几个方面进行讲解。</p><h4 id="4-1-多表关系"><a href="#4-1-多表关系" class="headerlink" title="4.1 多表关系"></a>4.1 多表关系</h4><p>项目开发中，在进行数据库表结构设计时，会根据业务需求及业务模块之间的关系，分析并设计表结构，由于业务之间相互关联，所以各个表结构之间也存在着各种联系，基本上分为三种：<br>一对多(多对一)<br>多对多<br>一对一 </p><h5 id="4-1-1-一对多"><a href="#4-1-1-一对多" class="headerlink" title="4.1.1 一对多"></a>4.1.1 一对多</h5><p>案例: 部门 与 员工的关系<br>关系: 一个部门对应多个员工，一个员工对应一个部门<br>实现: 在多的一方建立外键，指向一的一方的主键</p><h5 id="4-1-2-多对多"><a href="#4-1-2-多对多" class="headerlink" title="4.1.2 多对多"></a>4.1.2 多对多</h5><p>案例: 学生 与 课程的关系<br>关系: 一个学生可以选修多门课程，一门课程也可以供多个学生选择<br>实现: 建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><p>对应的SQL脚本:<br>create table student(<br>id int auto_increment primary key comment ‘主键ID’,<br>name varchar(10) comment ‘姓名’,<br>no varchar(10) comment ‘学号’<br>) comment ‘学生表’;<br>insert into student values (null, ‘黛绮丝’, ‘2000100101’),(null, ‘谢逊’,<br>‘2000100102’),(null, ‘殷天正’, ‘2000100103’),(null, ‘韦一笑’, ‘2000100104’);<br>create table course(<br>id int auto_increment primary key comment ‘主键ID’,<br>name varchar(10) comment ‘课程名称’<br>) comment ‘课程表’;<br>insert into course values (null, ‘Java’), (null, ‘PHP’), (null , ‘MySQL’) ,<br>(null, ‘Hadoop’);<br>create table student_course(<br>id int auto_increment comment ‘主键’ primary key,<br>studentid int not null comment ‘学生ID’,<br>courseid int not null comment ‘课程ID’,<br>constraint fk_courseid foreign key (courseid) references course (id),<br>constraint fk_studentid foreign key (studentid) references student (id)<br>)comment ‘学生课程中间表’;<br>insert into student_course values (null,1,1),(null,1,2),(null,1,3),(null,2,2),<br>(null,2,3),(null,3,4); </p><h5 id="4-1-3-一对一"><a href="#4-1-3-一对一" class="headerlink" title="4.1.3 一对一"></a>4.1.3 一对一</h5><p>案例: 用户 与 用户详情的关系<br>关系: 一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另<br>一张表中，以提升操作效率<br>实现: 在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)</p><p>对应的SQL脚本:<br>create table tb_user(<br>id int auto_increment primary key comment ‘主键ID’,<br>name varchar(10) comment ‘姓名’,<br>age int comment ‘年龄’,<br>gender char(1) comment ‘1: 男 , 2: 女’,<br>phone char(11) comment ‘手机号’<br>) comment ‘用户基本信息表’;<br>create table tb_user_edu(<br>id int auto_increment primary key comment ‘主键ID’,<br>degree varchar(20) comment ‘学历’,<br>major varchar(50) comment ‘专业’,<br>primaryschool varchar(50) comment ‘小学’,<br>middleschool varchar(50) comment ‘中学’,<br>university varchar(50) comment ‘大学’,<br>userid int unique comment ‘用户ID’,<br>constraint fk_userid foreign key (userid) references tb_user(id)<br>) comment ‘用户教育信息表’;<br>insert into tb_user(id, name, age, gender, phone) values<br>(null,’黄渤’,45,’1’,’18800001111’),<br>(null,’冰冰’,35,’2’,’18800002222’),<br>(null,’码云’,55,’1’,’18800008888’),<br>(null,’李彦宏’,50,’1’,’18800009999’);<br>insert into tb_user_edu(id, degree, major, primaryschool, middleschool,<br>university, userid) values<br>(null,’本科’,’舞蹈’,’静安区第一小学’,’静安区第一中学’,’北京舞蹈学院’,1),<br>(null,’硕士’,’表演’,’朝阳区第一小学’,’朝阳区第一中学’,’北京电影学院’,2),<br>(null,’本科’,’英语’,’杭州市第一小学’,’杭州市第一中学’,’杭州师范大学’,3),<br>(null,’本科’,’应用数学’,’阳泉第一小学’,’阳泉区第一中学’,’清华大学’,4); </p><h4 id="4-2-多表查询概述"><a href="#4-2-多表查询概述" class="headerlink" title="4.2 多表查询概述"></a>4.2 多表查询概述</h4><h5 id="4-2-1-数据准备"><a href="#4-2-1-数据准备" class="headerlink" title="4.2.1 数据准备"></a>4.2.1 数据准备</h5><p>1). 删除之前 emp, dept表的测试数据<br>2). 执行如下脚本，创建emp表与dept表并插入测试数据<br>– 创建dept表，并插入数据<br>create table dept(<br>id int auto_increment comment ‘ID’ primary key,<br>name varchar(50) not null comment ‘部门名称’<br>)comment ‘部门表’;<br>INSERT INTO dept (id, name) VALUES (1, ‘研发部’), (2, ‘市场部’),(3, ‘财务部’), (4,<br>‘销售部’), (5, ‘总经办’), (6, ‘人事部’);<br>– 创建emp表，并插入数据<br>create table emp(<br>id int auto_increment comment ‘ID’ primary key,<br>name varchar(50) not null comment ‘姓名’,<br>age int comment ‘年龄’,<br>job varchar(20) comment ‘职位’,<br>salary int comment ‘薪资’,<br>entrydate date comment ‘入职时间’,<br>managerid int comment ‘直属领导ID’,<br>dept_id int comment ‘部门ID’<br>)comment ‘员工表’;<br>– 添加外键<br>alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references<br>dept(id);<br>INSERT INTO emp (id, name, age, job,salary, entrydate, managerid, dept_id)<br>VALUES<br>(1, ‘金庸’, 66, ‘总裁’,20000, ‘2000-01-01’, null,5),<br>(2, ‘张无忌’, 20, ‘项目经理’,12500, ‘2005-12-05’, 1,1),<br>(3, ‘杨逍’, 33, ‘开发’, 8400,’2000-11-03’, 2,1),<br>(4, ‘韦一笑’, 48, ‘开发’,11000, ‘2002-02-05’, 2,1),<br>(5, ‘常遇春’, 43, ‘开发’,10500, ‘2004-09-07’, 3,1),<br>(6, ‘小昭’, 19, ‘程序员鼓励师’,6600, ‘2004-10-12’, 2,1),<br>(7, ‘灭绝’, 60, ‘财务总监’,8500, ‘2002-09-12’, 1,3),<br>(8, ‘周芷若’, 19, ‘会计’,48000, ‘2006-06-02’, 7,3),<br>(9, ‘丁敏君’, 23, ‘出纳’,5250, ‘2009-05-13’, 7,3),<br>(10, ‘赵敏’, 20, ‘市场部总监’,12500, ‘2004-10-12’, 1,2),<br>(11, ‘鹿杖客’, 56, ‘职员’,3750, ‘2006-10-03’, 10,2),<br>(12, ‘鹤笔翁’, 19, ‘职员’,3750, ‘2007-05-09’, 10,2),<br>(13, ‘方东白’, 19, ‘职员’,5500, ‘2009-02-12’, 10,2),<br>(14, ‘张三丰’, 88, ‘销售总监’,14000, ‘2004-10-12’, 1,4),<br>(15, ‘俞莲舟’, 38, ‘销售’,4600, ‘2004-10-12’, 14,4),<br>(16, ‘宋远桥’, 40, ‘销售’,4600, ‘2004-10-12’, 14,4),<br>(17, ‘陈友谅’, 42, null,2000, ‘2011-10-12’, 1,null);<br>dept表共6条记录，emp表共17条记录。</p><h5 id="4-2-2-概述"><a href="#4-2-2-概述" class="headerlink" title="4.2.2 概述"></a>4.2.2 概述</h5><p>多表查询就是指从多张表中查询数据。<br>原来查询单表数据，执行的SQL形式为：select * from emp;<br>那么我们要执行多表查询，就只需要使用逗号分隔多张表即可，如： select * from emp , dept<br>; 具体的执行结果如下:</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811093335499.png" alt="image-20230811093335499"></p><p>此时,我们看到查询结果中包含了大量的结果集，总共102条记录，而这其实就是员工表emp所有的记录 (17) 与 部门表dept所有记录(6) 的所有组合情况，这种现象称之为笛卡尔积。<br>笛卡尔积: 笛卡尔乘积是指在数学中，两个集合A集合 和 B集合的所有组合情况</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811093538758.png" alt="image-20230811093538758"></p><p>而在多表查询中，我们是需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811093554573.png" alt="image-20230811093554573"></p><p>在SQL语句中，如何来去除无效的笛卡尔积呢？ 我们可以给多表查询加上连接查询的条件即可。<br>select * from emp , dept where emp.dept_id &#x3D; dept.id;</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811093615569.png" alt="image-20230811093615569"></p><p>而由于id为17的员工，没有dept_id字段值，所以在多表查询时，根据连接查询的条件并没有查询到。 </p><h5 id="4-2-3-分类"><a href="#4-2-3-分类" class="headerlink" title="4.2.3 分类"></a>4.2.3 分类</h5><p>连接查询<br>内连接：相当于查询A、B交集部分数据<br>外连接：<br>左外连接：查询左表所有数据，以及两张表交集部分数据<br>右外连接：查询右表所有数据，以及两张表交集部分数据<br>自连接：当前表与自身的连接查询，自连接必须使用表别名<br>子查询</p><h4 id="4-3-内连接"><a href="#4-3-内连接" class="headerlink" title="4.3 内连接"></a>4.3 内连接</h4><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811094122958.png" alt="image-20230811094122958"></p><p>内连接查询的是两张表交集部分的数据。(也就是绿色部分的数据)<br>内连接的语法分为两种: 隐式内连接、显式内连接。先来学习一下具体的语法结构。<br>1). 隐式内连接<br>SELECT 字段列表 FROM 表1 , 表2 WHERE 条件 … ;<br>2). 显式内连接<br>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 … ;<br>案例:<br>A. 查询每一个员工的姓名 , 及关联的部门的名称 (隐式内连接实现)<br>表结构: emp , dept<br>连接条件: emp.dept_id &#x3D; dept.id<br>select emp.name , dept.name from emp , dept where emp.dept_id &#x3D; dept.id ;<br>– 为每一张表起别名,简化SQL编写<br>select e.name,d.name from emp e , dept d where e.dept_id &#x3D; d.id;<br>B. 查询每一个员工的姓名 , 及关联的部门的名称 (显式内连接实现) — INNER JOIN …<br>ON …<br>表结构: emp , dept<br>连接条件: emp.dept_id &#x3D; dept.id<br>select e.name, d.name from emp e inner join dept d on e.dept_id &#x3D; d.id;<br>– 为每一张表起别名,简化SQL编写<br>select e.name, d.name from emp e join dept d on e.dept_id &#x3D; d.id;<br>表的别名:<br>①. tablea as 别名1 , tableb as 别名2 ;<br>②. tablea 别名1 , tableb 别名2 ;<br>注意事项:<br>一旦为表起了别名，就不能再使用表名来指定对应的字段了，此时只能够使用别名来指定字<br>段。</p><h4 id="4-4-外连接"><a href="#4-4-外连接" class="headerlink" title="4.4 外连接"></a>4.4 外连接</h4><p>外连接分为两种，分别是：左外连接 和 右外连接。具体的语法结构为：<br>1). 左外连接<br>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 … ;<br>左外连接相当于查询表1(左表)的所有数据，当然也包含表1和表2交集部分的数据。<br>2). 右外连接<br>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 … ;<br>右外连接相当于查询表2(右表)的所有数据，当然也包含表1和表2交集部分的数据。<br>案例:<br>A. 查询emp表的所有数据, 和对应的部门信息<br>由于需求中提到，要查询emp的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。<br>表结构: emp, dept<br>连接条件: emp.dept_id &#x3D; dept.id<br>select e.<em>, d.name from emp e left outer join dept d on e.dept_id &#x3D; d.id;<br>select e.</em>, d.name from emp e left join dept d on e.dept_id &#x3D; d.id;<br>B. 查询dept表的所有数据, 和对应的员工信息(右外连接)<br>由于需求中提到，要查询dept表的所有数据，所以是不能内连接查询的，需要考虑使用外连接查询。<br>表结构: emp, dept<br>连接条件: emp.dept_id &#x3D; dept.id<br>select d.<em>, e.</em> from emp e right outer join dept d on e.dept_id &#x3D; d.id;<br>select d.<em>, e.</em> from dept d left outer join emp e on e.dept_id &#x3D; d.id;<br>注意事项：<br>左外连接和右外连接是可以相互替换的，只需要调整在连接查询时SQL中，表结构的先后顺序就可以了。而我们在日常开发使用时，更偏向于左外连接。</p><h4 id="4-5-自连接"><a href="#4-5-自连接" class="headerlink" title="4.5 自连接"></a>4.5 自连接</h4><h5 id="4-5-1-自连接查询"><a href="#4-5-1-自连接查询" class="headerlink" title="4.5.1 自连接查询"></a>4.5.1 自连接查询</h5><p>自连接查询，顾名思义，就是自己连接自己，也就是把一张表连接查询多次。<br>自连接 的查询语法：<br>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 … ;<br>而对于自连接查询，可以是内连接查询，也可以是外连接查询。<br>案例：<br>A. 查询员工 及其 所属领导的名字<br>表结构: emp<br>select a.name , b.name from emp a , emp b where a.managerid &#x3D; b.id;<br>B. 查询所有员工 emp 及其领导的名字 emp , 如果员工没有领导, 也需要查询出来<br>表结构: emp a , emp b<br>select a.name ‘员工’, b.name ‘领导’ from emp a left join emp b on a.managerid &#x3D;<br>b.id;<br><strong>注意事项:<br>在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底<br>是哪一张表的字段。</strong></p><h5 id="4-5-2-联合查询"><a href="#4-5-2-联合查询" class="headerlink" title="4.5.2 联合查询"></a>4.5.2 联合查询</h5><p>对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。<br>SELECT 字段列表 FROM 表A …<br>UNION [ ALL ]<br>SELECT 字段列表 FROM 表B ….; </p><p>对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。<br>union all 会将全部的数据直接合并在一起，union 会对合并之后的数据去重。<br>案例:<br>A. 将薪资低于 5000 的员工 , 和 年龄大于 50 岁的员工全部查询出来.<br>当前对于这个需求，我们可以直接使用多条件查询，使用逻辑运算符 or 连接即可。 那这里呢，我们<br>也可以通过union&#x2F;union all来联合查询.<br>select * from emp where salary &lt; 5000<br>union all<br>select * from emp where age &gt; 50; </p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811094730517.png" alt="image-20230811094730517"></p><p>union all查询出来的结果，仅仅进行简单的合并，并未去重<br>select * from emp where salary &lt; 5000<br>union<br>select * from emp where age &gt; 50;</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811094744959.png" alt="image-20230811094744959"></p><p>union 联合查询，会对查询出来的结果进行去重处理<br><strong>注意：<br>如果多条查询语句查询出来的结果，字段数量不一致，在进行union&#x2F;union all联合查询时，将会报<br>错。如：</strong></p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811094821567.png" alt="image-20230811094821567"></p><h4 id="4-6-子查询"><a href="#4-6-子查询" class="headerlink" title="4.6 子查询"></a>4.6 子查询</h4><h5 id="4-6-1-概述"><a href="#4-6-1-概述" class="headerlink" title="4.6.1 概述"></a>4.6.1 概述</h5><p>1). 概念<br>SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。<br>SELECT * FROM t1 WHERE column1 &#x3D; ( SELECT column1 FROM t2 );<br>子查询外部的语句可以是INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个。<br>2). 分类<br>根据子查询结果不同，分为：<br>A. 标量子查询（子查询结果为单个值）<br>B. 列子查询(子查询结果为一列)<br>C. 行子查询(子查询结果为一行)<br>D. 表子查询(子查询结果为多行多列)<br>根据子查询位置，分为：<br>A. WHERE之后<br>B. FROM之后<br>C. SELECT之后 </p><h5 id="4-6-2-标量子查询"><a href="#4-6-2-标量子查询" class="headerlink" title="4.6.2 标量子查询"></a>4.6.2 标量子查询</h5><p>子查询返回的结果是单个值（数字、字符串、日期等），最简单的形式，这种子查询称为标量子查询。<br>常用的操作符：&#x3D; &lt;&gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;<br>案例:<br>A. 查询 “销售部” 的所有员工信息<br>完成这个需求时，我们可以将需求分解为两步：<br>①. 查询 “销售部” 部门ID<br>select id from dept where name &#x3D; ‘销售部’;<br>②. 根据 “销售部” 部门ID, 查询员工信息<br>select * from emp where dept_id &#x3D; (select id from dept where name &#x3D; ‘销售部’);<br>B. 查询在 “方东白” 入职之后的员工信息<br>完成这个需求时，我们可以将需求分解为两步：<br>①. 查询 方东白 的入职日期<br>select entrydate from emp where name &#x3D; ‘方东白’;<br>②. 查询指定入职日期之后入职的员工信息<br>select * from emp where entrydate &gt; (select entrydate from emp where name &#x3D; ‘方东<br>白’); </p><h5 id="4-6-3-列子查询"><a href="#4-6-3-列子查询" class="headerlink" title="4.6.3 列子查询"></a>4.6.3 列子查询</h5><p>子查询返回的结果是一列（可以是多行），这种子查询称为列子查询。<br>常用的操作符：IN 、NOT IN 、 ANY 、SOME 、 ALL</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811095528630.png" alt="image-20230811095528630"></p><p>案例:<br>A. 查询 “销售部” 和 “市场部” 的所有员工信息<br>分解为以下两步:<br>①. 查询 “销售部” 和 “市场部” 的部门ID<br>select id from dept where name &#x3D; ‘销售部’ or name &#x3D; ‘市场部’;<br>②. 根据部门ID, 查询员工信息<br>select * from emp where dept_id in (select id from dept where name &#x3D; ‘销售部’ or name &#x3D; ‘市场部’);<br>B. 查询比 财务部 所有人工资都高的员工信息<br>分解为以下两步:<br>①. 查询所有 财务部 人员工资<br>select id from dept where name &#x3D; ‘财务部’;<br>select salary from emp where dept_id &#x3D; (select id from dept where name &#x3D; ‘财务部’);<br>②. 比 财务部 所有人工资都高的员工信息<br>select * from emp where salary &gt; all ( select salary from emp where dept_id &#x3D;<br>(select id from dept where name &#x3D; ‘财务部’) );<br>C. 查询比研发部其中任意一人工资高的员工信息<br>分解为以下两步:<br>①. 查询研发部所有人工资<br>select salary from emp where dept_id &#x3D; (select id from dept where name &#x3D; ‘研发部’);<br>②. 比研发部其中任意一人工资高的员工信息<br>select * from emp where salary &gt; any ( select salary from emp where dept_id &#x3D;<br>(select id from dept where name &#x3D; ‘研发部’) ); </p><h5 id="4-6-4-行子查询"><a href="#4-6-4-行子查询" class="headerlink" title="4.6.4 行子查询"></a>4.6.4 行子查询</h5><p>子查询返回的结果是一行（可以是多列），这种子查询称为行子查询。<br>常用的操作符：&#x3D; 、&lt;&gt; 、IN 、NOT IN<br>案例:<br>A. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;<br>这个需求同样可以拆解为两步进行:<br>①. 查询 “张无忌” 的薪资及直属领导<br>select salary, managerid from emp where name &#x3D; ‘张无忌’;<br>②. 查询与 “张无忌” 的薪资及直属领导相同的员工信息 ;<br>select * from emp where (salary,managerid) &#x3D; (select salary, managerid from emp where name &#x3D; ‘张无忌’); </p><h5 id="4-6-5-表子查询"><a href="#4-6-5-表子查询" class="headerlink" title="4.6.5 表子查询"></a>4.6.5 表子查询</h5><p>子查询返回的结果是多行多列，这种子查询称为表子查询。<br>常用的操作符：IN<br>案例:<br>A. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息<br>分解为两步执行:<br>①. 查询 “鹿杖客” , “宋远桥” 的职位和薪资<br>select job, salary from emp where name &#x3D; ‘鹿杖客’ or name &#x3D; ‘宋远桥’;<br>②. 查询与 “鹿杖客” , “宋远桥” 的职位和薪资相同的员工信息<br>select * from emp where (job,salary) in ( select job, salary from emp where name &#x3D; ‘鹿杖客’ or name &#x3D; ‘宋远桥’ );<br>B. 查询入职日期是 “2006-01-01” 之后的员工信息 , 及其部门信息分解为两步执行:<br>①. 入职日期是 “2006-01-01” 之后的员工信息<br>select * from emp where entrydate &gt; ‘2006-01-01’;<br>②. 查询这部分员工, 对应的部门信息;<br>select e.<em>, d.</em> from (select * from emp where entrydate &gt; ‘2006-01-01’) e left<br>join dept d on e.dept_id &#x3D; d.id ;</p><h4 id="4-7-多表查询案例"><a href="#4-7-多表查询案例" class="headerlink" title="4.7 多表查询案例"></a>4.7 多表查询案例</h4><p>数据环境准备:<br>create table salgrade(<br>grade int,<br>losal int,<br>hisal int<br>) comment ‘薪资等级表’;<br>insert into salgrade values (1,0,3000);<br>insert into salgrade values (2,3001,5000);<br>insert into salgrade values (3,5001,8000);<br>insert into salgrade values (4,8001,10000);<br>insert into salgrade values (5,10001,15000);<br>insert into salgrade values (6,15001,20000);<br>insert into salgrade values (7,20001,25000);<br>insert into salgrade values (8,25001,30000);<br>在这个案例中，我们主要运用上面所讲解的多表查询的语法，完成以下的12个需求即可，而这里主要涉<br>及到的表就三张：emp员工表、dept部门表、salgrade薪资等级表 。<br>1). 查询员工的姓名、年龄、职位、部门信息 （隐式内连接）<br>表: emp , dept<br>连接条件: emp.dept_id &#x3D; dept.id<br>select e.name , e.age , e.job , d.name from emp e , dept d where e.dept_id &#x3D; d.id;<br>2). 查询年龄小于30岁的员工的姓名、年龄、职位、部门信息（显式内连接）<br>表: emp , dept<br>连接条件: emp.dept_id &#x3D; dept.id<br>select e.name , e.age , e.job , d.name from emp e inner join dept d on e.dept_id &#x3D;<br>d.id where e.age &lt; 30;<br>3). 查询拥有员工的部门ID、部门名称表: emp , dept<br>连接条件: emp.dept_id &#x3D; dept.id<br>select distinct d.id , d.name from emp e , dept d where e.dept_id &#x3D; d.id;<br>4). 查询所有年龄大于40岁的员工, 及其归属的部门名称; 如果员工没有分配部门, 也需要展示出<br>来(外连接)<br>表: emp , dept<br>连接条件: emp.dept_id &#x3D; dept.id<br>select e.<em>, d.name from emp e left join dept d on e.dept_id &#x3D; d.id where e.age &gt; 40 ;<br>5). 查询所有员工的工资等级<br>表: emp , salgrade<br>连接条件 : emp.salary &gt;&#x3D; salgrade.losal and emp.salary &lt;&#x3D; salgrade.hisal<br>– 方式一<br>select e.* , s.grade , s.losal, s.hisal from emp e , salgrade s where e.salary &gt;&#x3D;<br>s.losal and e.salary &lt;&#x3D; s.hisal;<br>– 方式二<br>select e.* , s.grade , s.losal, s.hisal from emp e , salgrade s where e.salary<br>between s.losal and s.hisal;<br>6). 查询 “研发部” 所有员工的信息及 工资等级<br>表: emp , salgrade , dept<br>连接条件 : emp.salary between salgrade.losal and salgrade.hisal ,<br>emp.dept_id &#x3D; dept.id<br>查询条件 : dept.name &#x3D; ‘研发部’<br>select e.* , s.grade from emp e , dept d , salgrade s where e.dept_id &#x3D; d.id and (<br>e.salary between s.losal and s.hisal ) and d.name &#x3D; ‘研发部’;<br>7). 查询 “研发部” 员工的平均工资<br>表: emp , dept<br>连接条件 : emp.dept_id &#x3D; dept.id<br>select avg(e.salary) from emp e, dept d where e.dept_id &#x3D; d.id and d.name &#x3D; ‘研发部’;<br>8). 查询工资比 “灭绝” 高的员工信息。<br>①. 查询 “灭绝” 的薪资<br>select salary from emp where name &#x3D; ‘灭绝’;<br>②. 查询比她工资高的员工数据<br>select * from emp where salary &gt; ( select salary from emp where name &#x3D; ‘灭绝’ );<br>9). 查询比平均薪资高的员工信息<br>①. 查询员工的平均薪资<br>select avg(salary) from emp;<br>②. 查询比平均薪资高的员工信息<br>select * from emp where salary &gt; ( select avg(salary) from emp );<br>10). 查询低于本部门平均工资的员工信息<br>①. 查询指定部门平均薪资<br>select avg(e1.salary) from emp e1 where e1.dept_id &#x3D; 1;<br>select avg(e1.salary) from emp e1 where e1.dept_id &#x3D; 2;<br>②. 查询低于本部门平均工资的员工信息<br>select * from emp e2 where e2.salary &lt; ( select avg(e1.salary) from emp e1 where<br>e1.dept_id &#x3D; e2.dept_id );<br>11). 查询所有的部门信息, 并统计部门的员工人数<br>select d.id, d.name , ( select count(</em>) from emp e where e.dept_id &#x3D; d.id ) ‘人数’ from dept d;<br>12). 查询所有学生的选课情况, 展示出学生名称, 学号, 课程名称<br>表: student , course , student_course<br>连接条件: student.id &#x3D; student_course.studentid , course.id &#x3D;<br>student_course.courseid<br>select s.name , s.no , c.name from student s , student_course sc , course c where<br>s.id &#x3D; sc.studentid and sc.courseid &#x3D; c.id ; </p><p>备注: 以上需求的实现方式可能会很多, SQL写法也有很多，只要能满足我们的需求，查询出符合条<br>件的记录即可。</p><h2 id="5-事务"><a href="#5-事务" class="headerlink" title="5. 事务"></a>5. 事务</h2><h4 id="5-1-事务简介"><a href="#5-1-事务简介" class="headerlink" title="5.1 事务简介"></a>5.1 事务简介</h4><p>**事务<br>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。<br>就比如: 张三给李四转账1000块钱，张三银行账户的钱减少1000，而李四银行账户的钱要增加 1000。 这一组操作就必须在一个事务的范围内，要么都成功，要么都失败。<br>**</p><p>正常情况: 转账这个操作, 需要分为以下这么三步来完成 , 三步完成之后, 张三减少1000, 而李四增加1000, 转账成功 : </p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811101914199.png" alt="image-20230811101914199"></p><p>异常情况: 转账这个操作, 也是分为以下这么三步来完成 , 在执行第三步是报错了, 这样就导致张三减少1000块钱, 而李四的金额没变, 这样就造成了数据的不一致, 就出现问题了。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811101952287.png" alt="image-20230811101952287"></p><p>为了解决上述的问题，就需要通过数据的事务来完成，我们只需要在业务逻辑执行之前开启事务，执行 完毕后提交事务。如果执行过程中报错，则回滚事务，把数据恢复到事务开始之前的状态</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811102011929.png" alt="image-20230811102011929"></p><p>注意： 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。</p><h4 id="5-2-事务操作"><a href="#5-2-事务操作" class="headerlink" title="5.2 事务操作"></a>5.2 事务操作</h4><p>数据准备：<br>drop table if exists account;<br>create table account(<br>id int primary key AUTO_INCREMENT comment ‘ID’,<br>name varchar(10) comment ‘姓名’,<br>money double(10,2) comment ‘余额’<br>) comment ‘账户表’;<br>insert into account(name, money) VALUES (‘张三’,2000), (‘李四’,2000); </p><h5 id="5-2-1-未控制事务"><a href="#5-2-1-未控制事务" class="headerlink" title="5.2.1 未控制事务"></a>5.2.1 未控制事务</h5><p>1). 测试正常情况<br>– 1. 查询张三余额<br>select * from account where name &#x3D; ‘张三’;<br>– 2. 张三的余额减少1000<br>update account set money &#x3D; money - 1000 where name &#x3D; ‘张三’;<br>– 3. 李四的余额增加1000<br>update account set money &#x3D; money + 1000 where name &#x3D; ‘李四’;<br>测试完毕之后检查数据的状态, 可以看到数据操作前后是一致的。 </p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811102259022.png" alt="image-20230811102259022"></p><p>2). 测试异常情况<br>– 1. 查询张三余额<br>select * from account where name &#x3D; ‘张三’;<br>– 2. 张三的余额减少1000<br>update account set money &#x3D; money - 1000 where name &#x3D; ‘张三’;<br>出错了….<br>– 3. 李四的余额增加1000<br>update account set money &#x3D; money + 1000 where name &#x3D; ‘李四’;<br>我们把数据都恢复到2000， 然后再次一次性执行上述的SQL语句(出错了…. 这句话不符合SQL语法,执行就会报错)，检查最终的数据情况, 发现数据在操作前后不一致了。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811102331541.png" alt="image-20230811102331541"></p><h5 id="5-2-2-控制事务一"><a href="#5-2-2-控制事务一" class="headerlink" title="5.2.2 控制事务一"></a>5.2.2 控制事务一</h5><p>1). 查看&#x2F;设置事务提交方式<br>SELECT @@autocommit ;<br>SET @@autocommit &#x3D; 0 ;<br>2). 提交事务<br>COMMIT;<br>3). 回滚事务<br>ROLLBACK;<br>注意：上述的这种方式，我们是修改了事务的自动提交行为, 把默认的自动提交修改为了手动提交, 此时我们执行的DML语句都不会提交, 需要手动的执行commit进行提交。</p><h5 id="5-2-3-控制事务二"><a href="#5-2-3-控制事务二" class="headerlink" title="5.2.3 控制事务二"></a>5.2.3 控制事务二</h5><p>1). 开启事务<br>START TRANSACTION 或 BEGIN ;<br>2). 提交事务<br>COMMIT;<br>3). 回滚事务<br>ROLLBACK;<br>转账案例：<br>– 开启事务<br>start transaction<br>– 1. 查询张三余额<br>select * from account where name &#x3D; ‘张三’;<br>– 2. 张三的余额减少1000<br>update account set money &#x3D; money - 1000 where name &#x3D; ‘张三’;<br>– 3. 李四的余额增加1000<br>update account set money &#x3D; money + 1000 where name &#x3D; ‘李四’;<br>– 如果正常执行完毕, 则提交事务<br>commit;<br>– 如果执行过程中报错, 则回滚事务<br>– rollback;</p><h4 id="5-3-事务四大特性"><a href="#5-3-事务四大特性" class="headerlink" title="5.3 事务四大特性"></a>5.3 事务四大特性</h4><p>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。<br>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。<br>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立<br>环境下运行。<br>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。<br>上述就是事务的四大特性，简称ACID。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811102448509.png" alt="image-20230811102448509"></p><h4 id="5-4-并发事务问题"><a href="#5-4-并发事务问题" class="headerlink" title="5.4 并发事务问题"></a>5.4 并发事务问题</h4><p>1). 赃读：一个事务读到另外一个事务还没有提交的数据。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811102514815.png" alt="image-20230811102514815"></p><p>比如B读取到了A未提交的数据<br>2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811102530730.png" alt="image-20230811102530730"></p><p>事务A两次读取同一条记录，但是读取到的数据却是不一样的。<br>3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据<br>已经存在，好像出现了 “幻影”。 </p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811102552607.png" alt="image-20230811102552607"></p><h4 id="5-5-事务隔离级别"><a href="#5-5-事务隔离级别" class="headerlink" title="5.5 事务隔离级别"></a>5.5 事务隔离级别</h4><p>为了解决并发事务所引发的问题，在数据库中引入了事务隔离级别。主要有以下几种：</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230811102610649.png" alt="image-20230811102610649"></p><p>1). 查看事务隔离级别<br>SELECT @@TRANSACTION_ISOLATION;<br>2). 设置事务隔离级别<br>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL { READ UNCOMMITTED |<br>READ COMMITTED | REPEATABLE READ | SERIALIZABLE }<br>注意：事务隔离级别越高，数据越安全，但是性能越低。</p><p>**搬运自柳老师<a class="link"   href="https://www.yuque.com/kongfangxiong-he6y0/ggnkub/vsqbbc?singleDoc#ipPt5" >语雀文档<i class="fas fa-external-link-alt"></i></a>**（lzks）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-SQL基础&quot;&gt;&lt;a href=&quot;#1-SQL基础&quot; class=&quot;headerlink&quot; title=&quot;1. SQL基础&quot;&gt;&lt;/a&gt;1. SQL基础&lt;/h2&gt;&lt;h4 id=&quot;1-1-数据库相关概念&quot;&gt;&lt;a href=&quot;#1-1-数据库相关概念&quot; class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机基础</title>
    <link href="http://example.com/2023/08/02/bb/"/>
    <id>http://example.com/2023/08/02/bb/</id>
    <published>2023-08-02T10:54:13.000Z</published>
    <updated>2023-08-04T08:47:16.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>常见端口：iis，tomcat，阿帕奇，http，https，ftp，dns<br>状态码：<br>200正常<br>300重定向<br>400客户端错误<br>500服务器错误</p><table><thead><tr><th align="center">码</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">100</td><td align="center">继续</td></tr><tr><td align="center">200</td><td align="center">正常</td></tr><tr><td align="center">401</td><td align="center">未授权</td></tr><tr><td align="center">402</td><td align="center">需付费</td></tr><tr><td align="center">403</td><td align="center">禁止访问</td></tr><tr><td align="center">404</td><td align="center">无法找到</td></tr><tr><td align="center">405</td><td align="center">方法不被允许</td></tr><tr><td align="center">406</td><td align="center">无法接受</td></tr><tr><td align="center">408</td><td align="center">请求超时</td></tr><tr><td align="center">409</td><td align="center">指令冲突</td></tr><tr><td align="center">413</td><td align="center">请求实体过大</td></tr><tr><td align="center">414</td><td align="center">所请求的URL地址过长</td></tr><tr><td align="center">416</td><td align="center">请求的范围无法被满足</td></tr><tr><td align="center">417</td><td align="center">预期内容错误</td></tr><tr><td align="center">426</td><td align="center">需升级</td></tr><tr><td align="center">429</td><td align="center">请求数过多</td></tr><tr><td align="center">431</td><td align="center">请求的头字段过大</td></tr><tr><td align="center">450</td><td align="center">已被windows家长控制程序屏蔽</td></tr><tr><td align="center">500</td><td align="center">内部服务器错误</td></tr><tr><td align="center">507</td><td align="center">存量不足</td></tr><tr><td align="center">599</td><td align="center">错误：网络连接超时</td></tr></tbody></table><p><em>https&#x3D;http+tls&#x2F;ssl</em></p><h3 id="HTTP请求方式"><a href="#HTTP请求方式" class="headerlink" title="HTTP请求方式"></a>HTTP请求方式</h3><p>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。<br>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。<br>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p><table><thead><tr><th align="center">序号</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">GET</td><td align="center">请求指定的页面信息，并返回实体主体。（只接收）</td></tr><tr><td align="center">2</td><td align="center">HEAD</td><td align="center">类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td align="center">3</td><td align="center">POST</td><td align="center">向指定资源提交数据进行处理请求（例如提交表单或者上传文件。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td></tr><tr><td align="center">4</td><td align="center">PUT</td><td align="center">从客户端向服务器传送的数据取代指定的文档的内容。</td></tr><tr><td align="center">5</td><td align="center">DELETE</td><td align="center">请求服务器删除指定的页面。</td></tr><tr><td align="center">6</td><td align="center">CONNECT</td><td align="center">HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td></tr><tr><td align="center">7</td><td align="center">OPTIONS</td><td align="center">允许客户端查看服务器的性能。</td></tr><tr><td align="center">8</td><td align="center">TRACE</td><td align="center">回显服务器收到的请求，主要用于测试或诊断。</td></tr><tr><td align="center">9</td><td align="center">PATCH</td><td align="center">是对 PUT 方法的补充，用来对已知资源进行局部更新。</td></tr></tbody></table><h2 id="数据包结构"><a href="#数据包结构" class="headerlink" title="数据包结构"></a>数据包结构</h2><p>url:<br>请求协议:&#x2F;&#x2F;ip:port&#x2F;请求资源路径？get参数</p><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>是身份验证信息，个人标识，一个人一个网站通用一个cookie,通常保存3天。<br>cookie欺骗：伪造cookie信息伪造其他用户进行登录。</p><blockquote><p>referer:来自哪个网址（从哪里访问）</p></blockquote><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230804162906156.png" alt="image-20230804162906156"></p><h3 id="CMD-常用命令总结"><a href="#CMD-常用命令总结" class="headerlink" title="CMD 常用命令总结"></a>CMD 常用命令总结</h3><p>小技巧：</p><p>输入 help，查看帮助；<br>Tab 键，自动补全；<br>上&#x2F;下方向键，查看历史命令；<br>右键窗口标题栏 -&gt; 属性，可以修改外观样式。</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230804163308583.png" alt="image-20230804163308583"></p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230804163331288.png" alt="image-20230804163331288"></p><h3 id="LINUX常用命令总结"><a href="#LINUX常用命令总结" class="headerlink" title="LINUX常用命令总结"></a>LINUX常用命令总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">cd .. 返回上一级目录</span><br><span class="line">cd ../.. 返回上两级目录</span><br><span class="line">cd 进入个人的主目录</span><br><span class="line">cd ~user1 进入个人的主目录</span><br><span class="line">cd - 返回上次所在的目录</span><br><span class="line">pwd 显示工作路径</span><br><span class="line">ls 查看目录中的文件</span><br><span class="line">ls -F 查看目录中的文件</span><br><span class="line">ls -l 显示文件和目录的详细资料</span><br><span class="line">ls -a 显示隐藏文件</span><br><span class="line">ls *[0-9]* 显示包含数字的文件名和目录名</span><br><span class="line">tree 显示文件和目录由根目录开始的树形结构(1)</span><br><span class="line">lstree 显示文件和目录由根目录开始的树形结构(2)</span><br><span class="line">mkdir dir1 创建一个叫做 &#x27;dir1&#x27; 的目录&#x27;</span><br><span class="line">mkdir dir1 dir2 同时创建两个目录</span><br><span class="line">rm -f file1 删除一个叫做 &#x27;file1&#x27; 的文件&#x27;</span><br><span class="line">rmdir dir1 删除一个叫做 &#x27;dir1&#x27; 的目录&#x27;</span><br><span class="line">rm -rf dir1 删除一个叫做 &#x27;dir1&#x27; 的目录并同时删除其内容</span><br><span class="line">rm -rf dir1 dir2 同时删除两个目录及它们的内容</span><br><span class="line">mv dir1 new_dir 重命名/移动 一个目录</span><br><span class="line">cp file1 file2 复制一个文件</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;p&gt;常见端口：iis，tomcat，阿帕奇，http，https，ftp，dns&lt;br&gt;状态码：&lt;br&gt;200正常&lt;br&gt;300</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>端口速查</title>
    <link href="http://example.com/2023/07/29/aab/"/>
    <id>http://example.com/2023/07/29/aab/</id>
    <published>2023-07-29T09:35:21.000Z</published>
    <updated>2023-08-02T10:54:49.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重要端口及服务"><a href="#重要端口及服务" class="headerlink" title="重要端口及服务"></a>重要端口及服务</h1><table><thead><tr><th>port</th><th>service</th><th>description</th></tr></thead><tbody><tr><td>21</td><td>FTP</td><td>FTP控制端口，检查匿名登录、弱口令</td></tr><tr><td>22</td><td>SSH</td><td>SSH远程登录协议，检查弱口令</td></tr><tr><td>23</td><td>Telnet</td><td>Telnet终端仿真协议</td></tr><tr><td>53</td><td>DNS服务</td><td></td></tr><tr><td>80</td><td>Web</td><td>检查常见Web漏洞及管理后台</td></tr><tr><td>111</td><td>NFS</td><td>网络文件系统</td></tr><tr><td>389</td><td>LDAP</td><td>轻型目录访问协议，检查是否存在匿名访问</td></tr><tr><td>443</td><td>OpenSSL</td><td>检查心脏滴血及Web漏洞</td></tr><tr><td>445</td><td>SMB</td><td>检查是否存在MS17-010、MS08-067漏洞</td></tr><tr><td>512</td><td>Rexec</td><td>检查远程shell命令及暴力破解</td></tr><tr><td>873</td><td>Rsync</td><td>检查匿名登录、弱口令</td></tr><tr><td>1433</td><td>SQL Server</td><td>数据库服务</td></tr><tr><td>1521</td><td>Oracle</td><td>数据库服务</td></tr><tr><td>2049</td><td>NFS</td><td>NFS未授权访问</td></tr><tr><td>2181</td><td>Zookeeper</td><td>分布式协调系统</td></tr><tr><td>2375</td><td>Docker Remote</td><td>API未授权访问</td></tr><tr><td>3306</td><td>MySQL</td><td>数据库服务</td></tr><tr><td>3389</td><td>RDP</td><td>远程桌面</td></tr><tr><td>4848</td><td>GlassFish</td><td>未授权访问</td></tr><tr><td>5432</td><td>PostgreSQL</td><td>数据库服务</td></tr><tr><td>5601</td><td>Kibana</td><td>开源分析及可视化平台</td></tr><tr><td>5672</td><td>RabbitMQ</td><td>开源消息队列服务软件</td></tr><tr><td>5900</td><td>VNC</td><td>远程桌面控制软件，检查弱口令</td></tr><tr><td>5984</td><td>CouchDB</td><td>数据库服务</td></tr><tr><td>6379</td><td>Redis</td><td>数据库服务</td></tr><tr><td>7001</td><td>Weblogic</td><td>Weblogic Console默认端口</td></tr><tr><td>8000-9090</td><td>Web</td><td>常见Web端口，运维一般将管理后台开在这些非80端口上</td></tr><tr><td>8080</td><td>Jenkins</td><td></td></tr><tr><td>8080</td><td>Kubernetes Api Server</td><td></td></tr><tr><td>8081</td><td>Apache-Flink</td><td></td></tr><tr><td>8089</td><td>Druid</td><td></td></tr><tr><td>8090</td><td>Confluence</td><td></td></tr><tr><td>8095</td><td>Atlassian Crowd</td><td></td></tr><tr><td>8161</td><td>Active MQ</td><td></td></tr><tr><td>8888</td><td>Jupyter Notebook</td><td></td></tr><tr><td>8983</td><td>Solr</td><td></td></tr><tr><td>9000</td><td>Fast-CGI</td><td>对外访问可直接Get shell</td></tr><tr><td>9060</td><td>Websephere</td><td>管理端口</td></tr><tr><td>9092</td><td>Kafka</td><td>开源流处理平台</td></tr><tr><td>9200</td><td>Elasticsearch(http)</td><td>全文搜索引擎</td></tr><tr><td>9300</td><td>Elasticsearch(tcp)</td><td>全文搜索引擎</td></tr><tr><td>10000</td><td>Virualmin&#x2F;Webmin</td><td>服务器虚拟主机管理系统</td></tr><tr><td>10051</td><td>Zabbix</td><td>监控系统</td></tr><tr><td>11211</td><td>Memcache</td><td>分布式高速缓存系统，检查未授权访问</td></tr><tr><td>20880</td><td>Dubbo</td><td>阿里巴巴开源分布式服务框架</td></tr><tr><td>27017</td><td>MongoDB</td><td>数据库服务</td></tr><tr><td>28017</td><td>MongoDB</td><td>数据库服务（统计页面）</td></tr><tr><td>50030</td><td>Hadoop Hive</td><td></td></tr><tr><td>50070</td><td>Hadoop</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重要端口及服务&quot;&gt;&lt;a href=&quot;#重要端口及服务&quot; class=&quot;headerlink&quot; title=&quot;重要端口及服务&quot;&gt;&lt;/a&gt;重要端口及服务&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;port&lt;/th&gt;
&lt;th&gt;service&lt;/th&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>信息收集</title>
    <link href="http://example.com/2023/07/29/ab/"/>
    <id>http://example.com/2023/07/29/ab/</id>
    <published>2023-07-29T09:30:13.000Z</published>
    <updated>2023-08-04T06:51:42.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><h4 id="什么是域名"><a href="#什么是域名" class="headerlink" title="什么是域名"></a>什么是域名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识（有时也指地理位置）。</span><br><span class="line">由于IP地址不方便记忆并且不能显示地址组织的名称和性质，人们设计出了域名，并通过域名系统（DNS，Domain Name System）来将域名和IP地址相互映射，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。（取自百度百科）</span><br><span class="line"></span><br><span class="line">一级域名：.com  .cn   .net   .org</span><br><span class="line">二级域名：.baidu   .google   .scholor</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><em>一个域名对应一个IP，它是网站的唯一标识。</em></p><h3 id="查找域名"><a href="#查找域名" class="headerlink" title="查找域名"></a>查找域名</h3><h5 id="在线查找"><a href="#在线查找" class="headerlink" title="在线查找"></a>在线查找</h5><p>1.<a class="link"   href="https://whois.cloud.tencent.com/" >域名信息查询–腾讯云<i class="fas fa-external-link-alt"></i></a><br>2.<a class="link"   href="https://whois.chinaz.com/" >站长之家<i class="fas fa-external-link-alt"></i></a><br>3.<a class="link"   href="https://www.whois.com/whois" >whois<i class="fas fa-external-link-alt"></i></a></p><hr><h5 id="LINUX查找子域名"><a href="#LINUX查找子域名" class="headerlink" title="LINUX查找子域名"></a>LINUX查找子域名</h5><p>1.在kali中实现域名扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lijiejie/subDomainsBrute  #下载克隆</span><br></pre></td></tr></table></figure><blockquote><p>ls 观察文件</p></blockquote><blockquote><p>cd可退出到根目录</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pip3 install dnspython==2.2.1 async_timeout #下载python3库</span><br><span class="line"></span><br><span class="line">cd subDomainsBrute #进入sub文件夹</span><br><span class="line"></span><br><span class="line">python3 subDomainsBrute.py baidu.com #扫描baidu.com</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">等待出现结果，生成名为baidu.com的txt文件</span><br><span class="line">All Done. 67 found, 59069 scanned in 144.8 seconds.</span><br><span class="line">Output file is baidu.com.txt</span><br></pre></td></tr></table></figure><blockquote><p>ctrl+z 退出</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在sub文件目录下</span><br><span class="line">cat baidu.com.txt #查看txt文件内容</span><br></pre></td></tr></table></figure><h2 id="社工"><a href="#社工" class="headerlink" title="社工"></a>社工</h2><p>1.社工库（人肉盒） </p><blockquote><p>telegram、暗网<br>2.谷歌语法</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Google基本语法</span><br><span class="line"></span><br><span class="line">在使用Google进行搜索时，我们通常只是简单的输入要搜索的内容,事实上我们还可以加入一些搜索引擎支持的通配符，这样我们就可以使得搜索结果更全面和准确。</span><br><span class="line"></span><br><span class="line">1、 加号(&quot;+&quot;)：搜索的结果中要包含后面的内容,这里需要注意的是，在“+”号前面要有一个空格。</span><br><span class="line"></span><br><span class="line">2.减号(“-&quot;)：搜索结果中去除我们写入的内容。</span><br><span class="line"></span><br><span class="line">3、 波浪号( &quot;~”)：搜索同义词，这样的搜索结果会更多。</span><br><span class="line"></span><br><span class="line">4、点号(&quot;.&quot;):作用是取代字符，例如&quot;war .3&quot;, 就会搜索到940,000个结果，但是我们如果输入war 3则会有32 ,500,000项结果。</span><br><span class="line"></span><br><span class="line">5.星号(“*”):包括所有字符,例如搜索war*&quot;,可以搜索到200,000项结果。</span><br><span class="line"></span><br><span class="line">6、双引号(”&quot;)强调整体，必须包含双引号中完整内容。</span><br><span class="line"></span><br><span class="line">高级Google搜索语法</span><br><span class="line"></span><br><span class="line">1. allintext：以网页正文内容中的冒个字符作为搜索条件，例a如&quot;allintext: 天气”。</span><br><span class="line"></span><br><span class="line">2、allintitle：在网页标题中搜索我们要查找的字符，例a如&quot;allintitle: 谷歌学术”。</span><br><span class="line"></span><br><span class="line">3、cache：意思是缓存，例如&quot;cache: www. baidu.com”。</span><br><span class="line"></span><br><span class="line">4. define：意思是词语的定义，例如: &quot;define: 中国”。</span><br><span class="line"></span><br><span class="line">5. filetype：意思是搜索指定格式的文件，例如filetype: MDB&quot;, 类似于这样的搜索通常都可以直接下载,这样搜索很可能搜索到别人的数据口。</span><br><span class="line"></span><br><span class="line">6、info:查找指定的网站基本信息，例如: &quot;info: www. baidu.com&quot;。</span><br><span class="line"></span><br><span class="line">7、link:查看连接的网站。例如&quot;link: www baidu.com&quot;。</span><br><span class="line"></span><br><span class="line">8、related:返回主页上连接的内容，例如&quot;related: www baidu.com”。</span><br><span class="line"></span><br><span class="line">9、site:制定一个特定的区域进行搜索, 也就是说如果site后面是一个网站，那么我们得到的内容就是关于这个网站的，例如: &quot;site: www baidu.com”。</span><br><span class="line"></span><br><span class="line">10、inurl:搜索得到你搜索内容的网址,例如: &quot;inurl: asp&quot;。</span><br></pre></td></tr></table></figure><p>3.<a class="link"   href="https://www.linkedin.cn/" >领英<i class="fas fa-external-link-alt"></i></a><br>4.<a class="link"   href="https://www.chsi.com.cn/" >学信网<i class="fas fa-external-link-alt"></i></a></p><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h4 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">域名系统（英文：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</span><br><span class="line">DNS作用分为：</span><br><span class="line">正向解析：根据主机名称（域名）查询IP地址</span><br><span class="line">反向解析：IP地址查询主机名称</span><br></pre></td></tr></table></figure><blockquote><ul><li>PC机本身自带DNS，协议先DNS再HTTP</li><li><em>DNS递归和迭代查询</em></li></ul></blockquote><h3 id="PING命令的作用"><a href="#PING命令的作用" class="headerlink" title="PING命令的作用"></a>PING命令的作用</h3><p>1.用来检测网络的连通情况和分析网络速度<br>2.根据域名得到服务器IP（未做CDN）<br>3.根据ping返回的TTL值判断对方所使用的<em>操作系统、数据包、经过路由数</em>（LINUX&lt;128 WINDOWS&gt;128）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte:数据包大小（字节）</span><br><span class="line">time:响应时间，时间越小，响应速度越快</span><br><span class="line">TTL:记录在DNS服务器存在时间，是IP协议包的一个值</span><br></pre></td></tr></table></figure><blockquote><p>*LINUX对大小写敏感，可判断服务器类型（更改域名大小写无法访问）</p></blockquote><h3 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h3><blockquote><ul><li>区分大小写</li></ul></blockquote><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.全面扫描：nmap  -A  192.168.0.12</span><br><span class="line">2.扫描指定的一个网段</span><br><span class="line">nmap  192.168.0.0/24  或者  nmap  192.168.0.1-200（扫描1-200的主机）</span><br><span class="line">3.简单扫描</span><br><span class="line">该扫描方式可以针对IP或者域名进行扫描，扫描方式迅速，可以很方便地发现目标端口的开放情况及主机在线情况。</span><br><span class="line">nmap   192.168.0.12</span><br><span class="line">4.查看版本号</span><br><span class="line">nmap   -V</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nmap，也就是Network Mapper，中文为“网络映射器”。Nmap是一款开源的网络探测和安全审核的工具，它的设计目标是快速地扫描大型网络。它是网络管理员必用的软件之一，以及用以评估网络系统保安。(详情见nmap操作说明)</span><br></pre></td></tr></table></figure><h3 id="dig：Kali自带域名查询系统"><a href="#dig：Kali自带域名查询系统" class="headerlink" title="dig：Kali自带域名查询系统"></a>dig：Kali自带域名查询系统</h3><blockquote><p>命令：# dig baidu.com</p></blockquote><p>第一段：查询参数和统计<br>第二段：查询内容<br>第三段：DNS返回回复<br>第四段：显示服务器管理网站的DNS记录</p><p><a class="link"   href="https://blog.csdn.net/qq_41982020/article/details/121231166" >命令链接<i class="fas fa-external-link-alt"></i></a></p><h4 id="DNS解析内容"><a href="#DNS解析内容" class="headerlink" title="DNS解析内容"></a>DNS解析内容</h4><p>A记录：IP地址记录<br>AAAA记录：IPV6地址记录<br>CNAME记录：别名记录<br>MX记录:邮件交换记录<br>NX记录：域名服务器记录<br>PTR记录：反向记录<br>TXT记录：域名相关信息记录</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN是将源站内容分发至全国所有的节点，从而缩短用户查看对象的延迟，提高用户访问网站的响应速度与网站的可用性的技术。它能够有效解决网络带宽小、用户访问量大、网点分布不均等问题。【全球域名分发，让用户就近访问数据，速度更快】</p><p><strong>一个域名解析出多个IP–可能是CDN</strong><br><strong>一个IP对应多个域名–泛解析（利用“*”做子域名，实现所有子域名都指向同一个IP地址)</strong></p><h4 id="分辨是否用CDN"><a href="#分辨是否用CDN" class="headerlink" title="分辨是否用CDN"></a>分辨是否用CDN</h4><p>1.<a class="link"   href="https://ping.chinaz.com/" >站长工具–多地PING<i class="fas fa-external-link-alt"></i></a><br>2.命令提示符nslookup命令解析出多个IP<br>3.ping命令（部分）</p><h4 id="如何绕过CDN找到真实IP？"><a href="#如何绕过CDN找到真实IP？" class="headerlink" title="如何绕过CDN找到真实IP？"></a>如何绕过CDN找到真实IP？</h4><p>1.<a class="link"   href="https://www.dnsdb.io/zh-cn/" >DNSdb<i class="fas fa-external-link-alt"></i></a><br>2.历史CDN记录<br>3.从CDN本身<br>4.网络空间引擎搜索（针对性搜索）<br>（1）<a class="link"   href="https://www.shodan.io/" >shodan<i class="fas fa-external-link-alt"></i></a>搜索网络空间中在线设备，可搜索指定设备<br>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">摄像头：webcam     路由器： cisco</span><br><span class="line">指定端口：prot:22</span><br><span class="line">指定服务：SSH</span><br><span class="line">指定国家：country:&quot;CN&quot;</span><br><span class="line">指定城市：city:&quot;changsha&quot;</span><br><span class="line">指定IP地址：host:x.x.x.x</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5.查询HTTPS证书</p><h2 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h2><p>内容管理系统（cms）【位于WEB前端、后端办公系统或流程之间的软件系统】<br>右击源码查看cms</p><h2 id="APP查询"><a href="#APP查询" class="headerlink" title="APP查询"></a>APP查询</h2><p><a class="link"   href="https://www.virustotal.com/gui/home/upload" >查询软件后门程序<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;域名&quot;&gt;&lt;a href=&quot;#域名&quot; class=&quot;headerlink&quot; title=&quot;域名&quot;&gt;&lt;/a&gt;域名&lt;/h2&gt;&lt;h4 id=&quot;什么是域名&quot;&gt;&lt;a href=&quot;#什么是域名&quot; class=&quot;headerlink&quot; title=&quot;什么是域名&quot;&gt;&lt;/a&gt;什么是域</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>利用typora,PicGo实现简单的博客文章管理</title>
    <link href="http://example.com/2023/07/28/a/"/>
    <id>http://example.com/2023/07/28/a/</id>
    <published>2023-07-28T07:59:30.000Z</published>
    <updated>2023-08-04T08:53:05.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>利用typora，PicGo实现简单的文章管理</p><p>1.typora是一个Markdown格式的编辑器<br>2.PicGo是一个自动上传图片到图床的工具</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1.<a class="link"   href="https://molunerfinn.com/PicGo/" >PicGo官网<i class="fas fa-external-link-alt"></i></a></p><p>2.<a class="link"   href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85" >PicGo手册<i class="fas fa-external-link-alt"></i></a></p><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><h4 id="图片上传的整体思路"><a href="#图片上传的整体思路" class="headerlink" title="图片上传的整体思路"></a>图片上传的整体思路</h4><p>9.typora的偏好设置</p><p>10.PicGo图床，将本地图片上传到GitHub网站</p><hr><h4 id="搭建流程"><a href="#搭建流程" class="headerlink" title="搭建流程"></a>搭建流程</h4><p>1.在github里再建一个存储库image1用于放图片<br>2.设置typora偏好设置</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/1.png" alt="1"></p><p>3.设置PicGo</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/2.png" alt="2"></p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/3.png" alt="3"></p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/4.png" alt="4"></p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/5.png" alt="5"></p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/6.png" alt="6"></p><p>然后就可以把图片复制粘贴进typora并上传到网上</p><blockquote><ul><li>轻松实现了插入图片的需求</li></ul></blockquote><p><strong>^^_</strong></p><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;利用typora，PicGo实现简单的文章管理&lt;/p&gt;
&lt;p&gt;1.typora是一个Markdown格式的编辑器&lt;br&gt;2.PicGo是一个</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>利用github搭建我的第一个hexo博客</title>
    <link href="http://example.com/2023/07/27/hello-world/"/>
    <id>http://example.com/2023/07/27/hello-world/</id>
    <published>2023-07-27T09:25:39.000Z</published>
    <updated>2023-08-04T08:21:53.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备前提"><a href="#准备前提" class="headerlink" title="准备前提"></a>准备前提</h2><p>1.提前安装好(node.js)[<a class="link"   href="https://nodejs.org/en]" >https://nodejs.org/en]<i class="fas fa-external-link-alt"></i></a> 左边的那个<br>2.提前安装好(GIt)[<a class="link"   href="https://git-scm.com/downloads]" >https://git-scm.com/downloads]<i class="fas fa-external-link-alt"></i></a><br>3.提前注册好一个github账号<br>4.如果文章图片没有显示，请自行挂代理</p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>1.在本地找个目录放博客源文件，路径不要有中文<br>2.在选定的目录中，右键Git Bash Here<br>3.使用npm命令安装Hexo，输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">hexo g </span><br></pre></td></tr></table></figure><p>构建好的效果如下：</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230727162224729.png" alt="image-20230727162224729"></p><p>4.检查网站雏形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo new x</span><br><span class="line">新建一个名为x的网页模块</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">完成后可以通过本机IP地址：4000预览页面</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;hexo clean </span><br><span class="line">&gt;清除页面设置</span><br><span class="line">&gt;hexo g</span><br><span class="line">&gt;hexo d #部署，可与hexo g 合并为 hexo d -g</span><br><span class="line">&gt;输入d后等待一会完成博客部署</span><br></pre></td></tr></table></figure><p>5.配置ssh</p><blockquote><p>cd ~&#x2F;.ssh #检查本机已存在的ssh密钥</p></blockquote><ul><li>如果提示：No such file or directory 说明你是第一次使用git。</li></ul><blockquote><p>ssh-keygen -t rsa -C “邮件地址”</p></blockquote><ul><li>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</li></ul><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230727164429991.png" alt="image-20230727164429991"></p><ul><li><p>key填写C:\Users\Administrator.ssh\id_rsa.pub中的内容</p></li><li><p>尝试ssh连接,测试是否成功</p></li></ul><blockquote><p>ssh -T <a class="link"   href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#111;&#109;" >&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#104;&#117;&#98;&#x2e;&#x63;&#111;&#109;<i class="fas fa-external-link-alt"></i></a> # 注意邮箱地址不用改</p></blockquote><ul><li>如果提示Are you sure you want to continue connecting (yes&#x2F;no)?，输入yes，然后会看到下面这个，就算成功：</li></ul><blockquote><p>Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.</p></blockquote><ul><li>在选中的位置(blog目录下)打开cmd(以管理员身份)</li></ul><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><ul><li>在上一个<em>Git Bash Here</em>还需要继续配置</li></ul><blockquote><p>git config –global user.name “xxx”&#x2F;&#x2F; 你的github用户名，非昵称<br>git config –global user.email “<a class="link"   href="mailto:&#120;&#x78;&#x78;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;" >&#120;&#x78;&#x78;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;<i class="fas fa-external-link-alt"></i></a>“&#x2F;&#x2F; 填写你的github注册邮箱</p></blockquote><p>6.准备上传代码</p><ul><li><p>在github上新建一个存储库，命名为<em>github的用户名.github.io</em></p></li><li><p>编辑_config.yml文件，在最后改成这样</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:xxx/xxx.github.io.git</span><br><span class="line">branch: main</span><br></pre></td></tr></table></figure><p>!<img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230727165313253.png" alt="image-20230727165313253"></p><ul><li><p>注意保持格式，缩进不对，会导致一会儿，上传不成功</p></li><li><p>最后上传</p><p><img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230727165700767.png" alt="image-20230727165700767"></p></li><li><p>在创建的存储库的设置中-pages-如图设置</p><p>!<img src="https://raw.githubusercontent.com/braaain/image1/main/img/image-20230727170634788.png" alt="image-20230727170634788"></p></li></ul><p>7.hexo命令介绍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo g == hexo generate #生成</span><br><span class="line">hexo s == hexo server #启动服务预览</span><br><span class="line">hexo d == hexo deploy #部署</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo server #Hexo会监视文件变动并自动更新，无须重启服务器</span><br><span class="line">hexo server -s #静态模式</span><br><span class="line">hexo server -p 5000 #更改端口</span><br><span class="line">hexo server -i 192.168.1.1 #自定义 IP</span><br><span class="line">hexo clean #清除缓存，若是网页正常情况下可以忽略这条命令</span><br><span class="line">hexo version  #查看Hexo的版本</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br></pre></td></tr></table></figure><blockquote><p>hexo s -g #生成并本地预览<br>hexo d -g #生成并上传</p></blockquote><p>8.hexo目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+– .deploy #hexo deploy生成的文件</span><br><span class="line">+– node_modules #npm组件</span><br><span class="line">+– public #生成的静态网页文件</span><br><span class="line">+–scaffolds #模板</span><br><span class="line">+– source #博客正文和其他源文件</span><br><span class="line">| +– _posts #我们自己写的文章以md结尾</span><br><span class="line">+– themes #主题</span><br><span class="line">+– _config.yml #全局配置文件</span><br><span class="line">– package.json #定义了hexo所需要的各种模块</span><br></pre></td></tr></table></figure><p>9.markdown语法(typora)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;准备前提&quot;&gt;&lt;a href=&quot;#准备前提&quot; class=&quot;headerlink&quot; title=&quot;准备前提&quot;&gt;&lt;/a&gt;准备前提&lt;/h2&gt;&lt;p&gt;1.提前安装好(node.js)[&lt;a class=&quot;link&quot;   href=&quot;https://nodejs.org/en</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>欢迎光临地下室</title>
    <link href="http://example.com/2023/07/26/wuu/"/>
    <id>http://example.com/2023/07/26/wuu/</id>
    <published>2023-07-26T08:37:39.000Z</published>
    <updated>2023-07-31T08:33:54.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行"><a href="#阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行" class="headerlink" title="阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行"></a>阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行</h1><h2 id="！！！！"><a href="#！！！！" class="headerlink" title="！！！！"></a>！！！！</h2><p>(:靴洗针的狠剪丹:)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行&quot;&gt;&lt;a href=&quot;#阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行&quot; class=&quot;headerlink&quot; title=&quot;阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行阴暗地爬行&quot;&gt;&lt;/a&gt;阴暗地爬行阴暗地爬行阴</summary>
      
    
    
    
    
  </entry>
  
</feed>
